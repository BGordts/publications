\chapter{Multiagent Systems}

\begin{defi}[Sequence of decision elements, decision element, participation, positive set, neutral set, negative set, rate of return, degree of secure of rate $Z$, date of knowledge]
The structure decision $P$ of finite set of decision elements $E=\accol{e_1,e_2,\ldots,e_Y}$ is called as \term{sequence of decision elements}: $P=\tuple{\accol{EW^+},\accol{EW^{\pm}},\accol{EW^-},Z,SP,DT}$, Where:
\begin{enumerate}
 \item $EW^+=\tuple{e_0,pe_0},\tuple{e_q,pe_q},\ldots,\tuple{e_p,pe_p}$; couple $\tuple{e_x,pe_x}$, where $e_x\in E$ and $pe_x\in\ccinterval{0}{1}$. Denote a \term{decision element} and \term{participation} this element in set $EW^+$; decision element $e_x\in EW^+$ will be denoted as $e_x^+$; The set $EW^+$ is called \term{positive set}, in other words it is a set of decision elements, about which the agent knows that these elements are in the environment.
 \item $EW^{\pm}=\tuple{e_r,pe_r},\tuple{e_s,pe_s},\ldots,\tuple{e_t,pe_t}$; couple $\tuple{e_x,pe_x}$, where $e_x\in E$ and $pe_x\in\ccinterval{0}{1}$. Denote a decision element and participation this element in set $EW^+$; decision element $e_x\in EW^+$ will be denoted as $e_x^{\pm}$; The set $EW^{\pm}$ is called \term{neutral set}, in other words it is a set of decision elements, about which the agent does not know that these elements are in the environment.
 \item $EW^-=\tuple{e_r,pe_r},\tuple{e_s,pe_s},\ldots,\tuple{e_t,pe_t}$; couple $\tuple{e_x,pe_x}$, where $e_x\in E$ and $pe_x\in\ccinterval{0}{1}$. Denote a decision element and participation this element in set $EW^-$; decision element $e_x\in EW^+$ will be denoted as $e_x^-$; The set $EW^{\pm}$ is called a \term{negative set}, in other words it is a set of decision elements, about which the agent knows that these elements are not in the environment.
 \item $Z\in\ccinterval{0}{1}$ -- \term{rate of return}
 \item $SP\in\ccinterval{0}{1}$ -- \term{degree of secure of rate $Z$}
 \item $DT$ -- \term{date of knowledge}.
\end{enumerate}
\cite{conf/fedcsis/Sobieska-KarpinskaH12}
\end{defi}

\begin{defi}[Profile]
Set of decision elements $E=\accol{e_1,e_2,\ldots,e_Y}$ is given. A \term{profile} $A=\accol{A^{(1)},A^{(2)},\ldots,A^{(M)}}$ is called set of $M$ decisions of finite set of decision elements $E$, such that:
\begin{equation}
\group{
A^{(1)}=\tuple{\accol{EW^+}^{(1)},\accol{EW^{\pm}}^{(1)},\accol{EW^-}^{(1)},Z^{(1)},SP^{(1)},DT^{(1)}}\\\\
A^{(2)}=\tuple{\accol{EW^+}^{(2)},\accol{EW^{\pm}}^{(2)},\accol{EW^-}^{(2)},Z^{(2)},SP^{(2)},DT^{(2)}}\\\\
\vdots\\\\
A^{(M)}=\tuple{\accol{EW^+}^{(M)},\accol{EW^{\pm}}^{(M)},\accol{EW^-}^{(M)},Z^{(M)},SP^{(M)},DT^{(M)}}
}
\end{equation}
\cite{conf/fedcsis/Sobieska-KarpinskaH12}
\end{defi}

\section{Negotiation and Task Sharing}

\begin{defi}[Deal]
A \term{deal} is a division of $L_A\cup L_B$ to two disjoint subsets, \tuple{D_A,D_B} such that $D_A\cup D_B=L_A\cup L_B$ and $D_A\cap D_B=\emptyset$. This deal means that each agent $i$ agrees to deliver all the letters in $D_i$.
\cite{conf/ijcai/ZlotkinR89}
\end{defi}

\begin{defi}[Utility for an agent]
If \tuple{D_A,D_B} is a deal, then
\begin{equation}
\fun{\mbox{Utility}_i}{D_A,D_B}=\funm{Cost}{L_i}-\funm{Cost}{D_i}
\end{equation}
In other words, the \term[Utility for an agent]{utility for agent $i$} is the difference between the cost of achieving the goal alone and the cost of his part of the deal.
\cite{conf/ijcai/ZlotkinR89}
\end{defi}

\begin{defi}[Negotiation strategy]
A \term{negotiation strategy} is a function from the history of the negotiation to the current message (offer) that is consistent with the negotiation protocol.
\cite{conf/ijcai/ZlotkinR89}
\end{defi}

\begin{defi}[Rational negotiation strategy]
Agent $A$ will be said to be using a \term{rational negotiation strategy} if at any step $t+1$ that $A$ sticks to his last offer $\funm{Risk}{A,t}>\funm{Risk}{B,t}$
\cite{conf/ijcai/ZlotkinR89}
\end{defi}

\begin{defi}[Sufficient concessions, Minimal sufficient concession]
\funm{SC}{A,t} is the set of all the \term{sufficient concessions} of $A$ at step $t$. That is, if agent $A$ offers the ``next step'' a deal from \funm{SC}{A,t}, then if $B$ does not make a concession in the same ``next step'', $B$ will have to do so in the step after that (assuming that $B$ is using a rational strategy). $\delta^*$ will be a \term{minimal sufficient concession} of $A$ in step $t$ if $\fun{\mbox{Utility}_B}{\delta^*}=\displaystyle\min_{\delta\in\funm{SC}{A,t}}\fun{\mbox{Utility}_B}{\delta}$.
\cite{conf/ijcai/ZlotkinR89}
\end{defi}

\begin{defi}[Negotiation strategy in equilibrium]
A negotiation strategy $s$ will be in \term[Negotiation strategy in equilibrium]{equilibrium} if the following condition holds: under the assumption that $A$ uses $s$, $B$ prefers $s$ to any other strategy.
\cite{conf/ijcai/ZlotkinR89}
\end{defi}

\begin{defi}[Extended Zeuthen strategy]
The \term{extended Zeuthen strategy} will be the Zeuthen strategy, plus the ``last step equilibrium strategy'' in last step situations.
\cite{conf/ijcai/ZlotkinR89}
\end{defi}

\begin{defi}[Mixed deal]
If \tuple{D_A,D_B} is a deal and $0\leq p\leq 1$, $p\in\RRR$, then \flatbrak{\tuple{D_A,D_B}:p} will be a \term{mixed deal}. The meaning of such a deal is that the agents will perform \tuple{D_A,D_B} with probability $p$, or \tuple{D_B,D_A} with probability $1-p$.
\cite{conf/ijcai/ZlotkinR89}
\end{defi}

\begin{defi}[Cost for an agent with a mixed deal, Utility for an agent with a mixed deal]
If \flatbrak{\tuple{D_A,D_B}:p} is a mixed deal then \term[Cost for an agent with a mixed deal]{$\fun{\mbox{Cost}_i}{\flatbrak{\tuple{D_A,D_B}:p}}=p\cdot\funm{Cost}{D_i}+\brak{1-p}\cdot\funm{Cost}{D_j}$}. If \flatbrak{\delta:p} is a mixed deal then \term[Utility for an agent with a mixed deal]{$\fun{\mbox{Utility}_i}{\flatbrak{\delta:p}}=\funm{Cost}{L_i}-\fun{\mbox{Cost}_i}{\flatbrak{\delta:p}}$}.
\cite{conf/ijcai/ZlotkinR89}
\end{defi}

\begin{defi}[Agreement]
Let $Act$ be the set of actions required to satisfy a goal. An \term{agreement} is a pair \tuple{s_i,s_j}, where $i,j\in\calA$, $i\neq j$.
\cite{conf/ijcai/KrausW91}
\end{defi}

\begin{defi}[Strategy]
A \term{strategy} is a sequence of functions. The domain of the $i$th element of a strategy is a sequence of agreements of length $i$ and its range is the set $\accol{Y,N,O,N\circ p}\cup S$.
\cite{conf/ijcai/KrausW91}
\end{defi}

\begin{defi}[Outcome function of the negotiation]
The \term{outcome function of the negotiation} is defined by:
\begin{equation}
\fun{P}{f,g,h}=\left\{\begin{array}{ll}
D&\mbox{if }\fun{T}{f,g,h}=\infty\\
\tuple{\fun{La}{f,g,h},\fun{T}{f,g,h}-1}&\mbox{otherwise}
\end{array}\right.
\end{equation}
\cite{conf/ijcai/KrausW91}
\end{defi}

\begin{defi}[Worst agreement that can be reached in a period]
For every $t\in T$ and $i\in\calA$ we define $\overline{S}^{i^t}_{j\ l}=\accol{s|s\in S_{j\ l},\tuple{s,t}\succ_i\tuple{O,t},i,j,l\in\calA,j\neq l}$. Let $\overline{S}^{i^t}=\overline{S}^{i^t}_{i\ j}\cup\overline{S}^{i^t}_{i\ l}\cup\overline{S}^{i^t}_{j\ l}$, where $i,j,l\in\calA$, $i\neq j\neq l$. If $\overline{S}^{i^t}\neq\emptyset$, we denote $\hat{s}^{i^t}=\displaystyle\min_{\prec_i}\overline{S}^{i^t}$, i.e., $\hat{s}^{i^t}$ is the \term[Worst agreement that can be reached in a period]{worst agreement that can be reached in period} $t$ which is still better to agent $i$ than opting out. In case such an agreement does not exist, we define $\hat{s}^{i^t}=-1$.
\cite{conf/ijcai/KrausW91}
\end{defi}

\section{Planning, Scheduling and Reasoning about Actions}

\begin{defi}[Extension 1 $\prec^+$]
\term{Extension 1 ($\prec^+$)} is a binary relation over $G'$ where $G'=2^{G}$. For any $\accol{g_{k_i}}\in G'$ and any $\accol{g_{h_j}}\in G'$, $\accol{g_{k_i}}\prec^+\accol{g_{h_j}}$ \iffTx{}
\begin{equation}
\brak{\forall l\forall s\brak{\fun{T_l}{s}\in S_{\displaystyle\wedge_{i,j}g_{k_i},g_{h_j}}\rightarrow s\in S_{\displaystyle\wedge_ig_{k_i}}}}\wedge\forall g\in\accol{g_{h_j}\exists l\exists s\brak{\fun{T_l}{s}\in S_{\displaystyle\wedge_{i,j}g_{k_i},g_{h_j}}\wedge s\notin S_g}}
\end{equation}
\cite{conf/ijcai/ChengI89}
\end{defi}

\begin{defi}[Extension 2 $\prec^x$]
\term{Extension 2 ($\prec^x$)} is a binary relation from $2^G$ to $G$. For any $\accol{g_{k_i}}\in 2^G$ and any $g\in G$, $\accol{g_{k_i}}\prec^x g$ \iffTx{}
\begin{equation}
\brak{\forall l\forall s\brak{\fun{T_l}{s}\in S_{\displaystyle\wedge_ig_{k_i}\wedge g}\rightarrow s\in S_{\displaystyle\wedge_ig_{k_i}}}}\wedge\brak{\exists l\exists s\brak{\fun{T_l}{s}\in S_{\displaystyle\wedge_ig_{k_i}\wedge g}\wedge s\notin S_g}}
\end{equation}
\cite{conf/ijcai/ChengI89}
\end{defi}

\begin{defi}[$C_G$]
\term[Binary relation $C_G$]{$C_G$} is a binary relation over $G$. For $g_i\in G$ and $g_j\in G$, $\tuple{g_i,g_j}\in C_G$  \iffTx{} \teTx{} $g_{k_1},g_{k_2},\ldots,g_{k_m}$, \stTx{} $g_i\in\accol{g_{k_i}}$, $g_j\notin\accol{g_{k_i}}$ and $\accol{g_{k_i}}\prec^x g_j$.
\cite{conf/ijcai/ChengI89}
\end{defi}

\begin{defi}
\funsig{F}{2^{\prec^x}}{2^{C_G}} is an injective function. $\fun{F}{\accol{\tuple{\wedge_ig_{k_i},g}}}=\displaystyle\cup_i\accol{\tuple{g_{k_i},g}}$ and for any $S\subseteq\prec^+$, $\fun{F}{S}=\displaystyle\cup_{e\in S}\fun{F}{\accol{e}}$.
\cite{conf/ijcai/ChengI89}
\end{defi}

\begin{defi}[More effective subset of extension 2, most effective subrelation of extension 2]
Let $\prec_{\mbox{sub1}}^x$ and $\prec_{\mbox{sub2}}^x$ be subsets of $\prec^x$. $\prec_{\mbox{sub1}}^x$ is \term[More effective subset of extension 2]{more effective than} $\prec_{\mbox{sub2}}^x$ denoted $\prec_{\mbox{sub1}}^x\sqsubset\prec_{\mbox{sub1}}^x$ if $\abs{\prec_{\mbox{sub1}}^x}<\abs{\prec_{\mbox{sub2}}^x}$ and $\fun{f}{\prec_{\mbox{sub1}}^x}\supseteq\fun{f}{\prec_{\mbox{sub2}}^x}$. A subset of $\prec^x$ is the \term[most effective subrelation of extension 2]{most effective subrelation of $\prec^x$}, denoted by $\prec_{\mbox{min}}^x$ if for any $\prec_{\mbox{sub}}^x\subseteq\prec^x$, $\prec_{\mbox{min}}^x\sqsubset\prec_{\mbox{sub}}^x$
\cite{conf/ijcai/ChengI89}
\end{defi}

\begin{defi}[Binding of a postcondition, Binding of a precondition]
A \term[Binding of a postcondition]{binding $\pi$ of $\mbox{post}_k$} with a goal $G'$ is denoted by $\mbox{post}_k^{\pi}$ and is the result of assigning constants in $G$ to corresponding variables of matching formulas in $\mbox{post}_k$ and assigning arbitrary constants to the rest of the variables. A \term[Binding of a precondition]{binding $\pi$ of $\mbox{prec}_k$} with a goal $G$ is denoted by $\mbox{post}_k^{\pi}$ and is the result of passing the binding from $\mbox{post}_k$ to $\mbox{prec}_k$ and assigning arbitrary constants to the remaining variables.
\cite{conf/ijcai/ChengI89}
\end{defi}

\begin{defi}
A goal $G$ is consistent with a post condition $\mbox{post}_k$ under binding $\pi$ or simply \funm{con}{\mbox{post}_k^{\pi},G} if
\begin{enumerate}
 \item for all $g\in G$ it is not true that $\neg g$ is a logical consequence of $\mbox{post}_k^{\pi}$ and the preserved $\mbox{prec}_k^{\pi}$ formulas;
 \item None of the problem constraints are violated by the conjunction of $\mbox{post}_k^{\pi}$, $G$ and the preserved $\mbox{prec}_k^{\pi}$ formulas.
\end{enumerate}
\cite{conf/ijcai/ChengI89}
\end{defi}

\begin{defi}[Plan, start, finish]
The ordered pair $\Pi=\brak{O,<}$ is a \term{plan} \iffTx{}
\begin{enumerate}
 \item $O$ is a set of nodes containing at least the nodes \term{start} and \term{finish}, and
 \item $<\subseteq O\times O$ is a strict partial ordering on $O$ \stTx{} $\mbox{start}<\mbox{finish}$ and $\forall N\in O\setminus\accol{\mbox{start},\mbox{stop}}:\mbox{start}<N<\mbox{finish}$.
\end{enumerate}
\cite{conf/ijcai/HertzbergH89}
\end{defi}

\begin{defi}[Plan, Start, Finish]
The ordered pair $\Pi=\brak{O,<}$ is a \term{plan} \iffTx{}
\begin{enumerate}
 \item $O$ is a set of nodes containing at least the nodes \term{start} and \term{finish}, and
 \item $<\subseteq O\times O$ is a strict partial ordering on $O$ \stTx{} $\mbox{start}<\mbox{finish}$ and $\forall N\in O\setminus\accol{\mbox{start},\mbox{stop}}:\mbox{start}<N<\mbox{finish}$.
\end{enumerate}
\cite{conf/ijcai/HertzbergH89}
\end{defi}

\begin{defi}[User of a condition, Producer of a condition]
Let $N$ be a node with preconditions $\mbox{Pre}$ and postconditions $\mbox{Post}$, and $C$ a condition;
\begin{enumerate}
 \item $N$ is a \term[Producer of a condition]{producer of $C$} \iffTx{} $\mbox{Post}\vdash C$,
 \item $N$ is a \term[User of a condition]{user of $C$} \iffTx{} $C\in\mbox{Pre}$.
\end{enumerate}
\cite{conf/ijcai/HertzbergH89}
\end{defi}

\begin{defi}[Well formed plan]
Let $\Pi=\brak{O,<}$ be a plan, $\Pi$ is \term[Well formed plan]{well formed} \iffTx{} $\forall C\in\Lambda,\forall U\in O:$ if $U$ is user of $C$ then $\exists P\in O:$ $P$ is producer of $C$ and $P<U$.
\cite{conf/ijcai/HertzbergH89}
\end{defi}

\begin{defi}[Dependencies between producers and users of conditions]
Let $\Pi=\brak{O,<}$ be a plan, $C$ a condition and $P,U\in O$. Then $D=\tuple{P,C,U,\Pi}$ is a \term[Dependencies between producers and users of conditions]{dependency between $P$ and $U$ concerning $C$ in $\Pi$} \iffTx{}
\begin{enumerate}
 \item $P$ is a producer of $C$,
 \item $U$ is a user of $C$,
 \item $P<U$, and
 \item $\forall N\in O:$ if $P<N<U$ then $N$ is not a producer of $C$.
\end{enumerate}
\cite{conf/ijcai/HertzbergH89}
\end{defi}

\begin{defi}[Enclosure of a node in a dependency]
Let $\Pi=\brak{O,<}$ be a plan and $D=\tuple{P,C,U,\Pi}$ be a dependency between $P$ and $U$ concerning $C$. Then $D$ encloses $N\in O$ \iffTx{} $\exists<'\subseteq O\times O:<\subseteq<'$ and $P<'N<'U$. $<'$ is called the \term[Enclosure of a node in a dependency]{enclosure of $N$ in $D$}.
\cite{conf/ijcai/HertzbergH89}
\end{defi}

\begin{defi}[Conflict between a dependency and a node]
Let $\Pi=\brak{O,<}$ be a plan and $D=\tuple{P,C,U,\Pi}$ be a dependency between $P$ and $U$ concerning $C$, and $\mbox{Post}$ be the postconditions of $N\in O$. Then \tuple{D,N} is a \term[Conflict between a dependency and a node]{conflict between $D$ and $N$} \iffTx{}
\begin{enumerate}
 \item $\accol{C}\cup\mbox{Post}\vdash\mbox{false}$
 \item $D$ encloses $N$ with enclosure $<'$
 \item $\forall P'\in O:$ if $N<'P<'U$ then $P'$ is not a producer of $C$.
\end{enumerate}
\cite{conf/ijcai/HertzbergH89}
\end{defi}

\begin{defi}[General producer of a condition, Supporting condition set of a general producer]
Let $\calP=\accol{P_1,P_2,\ldots,P_p}$ be a set of nodes; let $C$ be a condition. $\calP$ is a \term[General producer of a condition]{general producer} of $C$ with \term[Supporting condition set of a general producer]{supporting condition set} $\calS=\accol{c_1,c_2,\ldots,c_p}\subseteq\Lambda$ \iffTx{} $\calS$ is a minimal consistent set \stTx{} $\calS\vdash C$ and $\forall i\in\accol{1,2,\ldots,p}:P_i$ is a producer of $c_i$.
\cite{conf/ijcai/HertzbergH89}
\end{defi}

\begin{defi}[General dependency concerning a condition in a plan]
Let $\Pi=\brak{O,<}$ be a plan, $C,c_1,c_2,\ldots,c_p$ conditions, $\calP=\accol{P_1,P_2,\ldots,P_p}\subseteq O$, $U\in O$. Then $\calD=\tuple{\calP,C,U,\calS,\Pi}$ is a \term[General dependency concerning a condition in a plan]{general dependency between $\calP$ and $U$ concerning $C$ in $\Pi$} \iffTx{}
\begin{enumerate}
 \item $\calP$ is a general producer of $C$ with supporting conditions set $\calS=\accol{c_1,c_2,\ldots,c_p}$,
 \item $U$ is a user of $C$,
 \item $\forall\calN\subseteq O\exists i\in\accol{1,2,\ldots,p}\forall N\in\calN:$ if $P_i<N<U$ then $\calN$ is not a general producer of $c_i$.
\end{enumerate}
\cite{conf/ijcai/HertzbergH89}
\end{defi}

\begin{defi}[General enclosure of a node by a dependency]
Let $\Pi=\brak{O,<}$ be a plan and $\calD=\tuple{\calP,C,U,\calS,\Pi}$ be a general dependency between $\calP$ and $U$ concerning $C$. Then $\calD$ generally encloses $N\in O$ by $P_i\in P$ \iffTx{} $\exists <'\subseteq O\times O\exists i\in\accol{1,2,\ldots,p}:<\subseteq<'$ and $P_i<'N<'U$. $<'$ is called a \term[General enclosure of a node by a dependency]{general enclosure of $N$ in $\calD$ in $P_i$}.
\cite{conf/ijcai/HertzbergH89}
\end{defi}

\begin{defi}[General conflict between a general dependency and a set of nodes]
Let $\Pi=\brak{O,<}$ be a plan, $\calP=\accol{P_1,P_2,\ldots,P_p}$, $\calD=\tuple{\calP,C,U,\calS,\Pi}$ a general dependency, and $\calN\subseteq O$. Then \tuple{\calD,\calN} is a \term[General conflict between a general dependency and a set of nodes]{general conflict between $\calD$ and $\calN$} \iffTx{} $\exists <'\subseteq O\times O\exists i\in\accol{1,2,\ldots,p}\exists N\in\calN$:
\begin{enumerate}
 \item $\calD$ generally encloses $N$ with $<'$ by $P_i$,
 \item $\calN$ is a general producer of $\neg c_i$ with supporting conditions set \accol{d_1,d_2,\ldots,d_n},
 \item \tiTx{} $<''\subseteq O\times O$ \stTx{} $<''\supseteq<'$ and the general dependency $\calD'=\tuple{\calN\setminus\accol{N},c_i,U,\accol{d_1,d_2,\ldots,d_n},\tuple{O',<''}}$ is not a general conflict in $\tuple{O',<''}$.
\end{enumerate}
Where \tuple{O',<'} is the plan resulting from replacing the node $N\in O$ by $N'$ with elements of $\accol{d_1,d_2,\ldots,d_n}\setminus\funm{Post}{N}$ as additional preconditions in \tuple{O,<'}.
\cite{conf/ijcai/HertzbergH89}
\end{defi}

\section{Action and Perception}

\begin{defi}[Abstract robotic domain, Configuration space in an abstract robotic domain, Transitions in an abstract robotic domain]
An \termabbrev{Abstract robotic domain}{ARD} is a pair \tuple{C,T} where $C$, the \term[Configuration space in an abstract robotic domain]{configuration space}, is a set of states, and $T$, the \term[Transitions in an abstract robotic domain]{transitions}, is a set of functions from $C$ to $2^C\setminus\emptyset$, containing the identity function.
\cite{conf/ijcai/BrafmanS95}
\end{defi}

\begin{defi}[History over a set]
A \term{history over a set} $W$ is a function \funsig{h}{\NNN}{W} where $\NNN$ are the integers.
\cite{conf/ijcai/BrafmanS95}
\end{defi}

\begin{defi}[Task]
A \term{task} is a pair $\funmt{Task}{I,G}$ where $I,G\subset\calC$.
\cite{conf/ijcai/BrafmanS95}
\end{defi}

\begin{defi}[Protocol of an abstract robotic unit]
A \term{protocol for an abstract robotic unit} is a function \funsig{\calP}{\mbox{States}}{\mbox{Actions}}.
\cite{conf/ijcai/BrafmanS95}
\end{defi}

\begin{defi}[Distributed protocol of an $n$-abstract robotic unit]
A \term{distributed protocol for an $n$-abstract robotic unit} is a set of functions \funsig{\calP}{\mbox{States}_i}{\mbox{Actions}_i} for $i=1,2,\ldots,n$.
\cite{conf/ijcai/BrafmanS95}
\end{defi}

\begin{defi}[Joint protocol]
A \term{joint protocol} is a (centralized) protocol for an $n$-abstract robotic unit, i.e., a function from $\mbox{States}_1\times\mbox{States}_2\times\ldots\times\mbox{States}_n$ to $\mbox{Actions}_1\times\mbox{Actions}_2\times\ldots\times\mbox{Actions}_n$.
\cite{conf/ijcai/BrafmanS95}
\end{defi}

\begin{defi}[Protocol performs a task]
A \term[Protocol performs a task]{protocol $\calP$ performs a task \funmt{Task}{I,G}} if every execution of $\calP$ that starts in \accol{\brak{c,l}|c\in I\wedge I\in\funm{Init}{c}} passes through a configuration in $G$.
\cite{conf/ijcai/BrafmanS95}
\end{defi}

\begin{defi}[Abstract robotic unit can perform a task]
An \term[Abstract robotic unit can perform a task]{abstract robotic unit can perform a task \funmt{Task}{I,G}} if \tiTx{} a protocol for it that performs \funmt{Task}{I,G}.
\cite{conf/ijcai/BrafmanS95}
\end{defi}

\begin{defi}[$K$-capable abstract robotic unit]
An abstract robotic unit is $K$-capable of $\accol{\varphi_0,\varphi_1,\ldots,\varphi_k}\subseteq\calL$ in a set of global states $S$ if \teTx{} a protocol $\calP$ \stTx{} \feTx{} $s\in\calS$, every execution of $\calP$ that starts at $s$ reaches a states $s'$ such that:
\begin{enumerate}
 \item $S,s'\vDash K\varphi_0\vee K\varphi_1\vee\ldots\vee K\varphi_k$;
 \item\label{itemb:kcapableabstractroboticunit} $s$ and $s'$ differ at most in the local state of the abstract robotic unit; and
 \item the abstract robotic unit knows that (\ref{itemb:kcapableabstractroboticunit}) holds.
\end{enumerate}
\cite{conf/ijcai/BrafmanS95}
\end{defi}

\begin{defi}[upper bound on the $K$-complexity of a task]
\accol{\varphi_0,\varphi_1,\ldots,\varphi_k} is an \term{upper bound on the $K$-complexity of a task} \funmt{Task}{I,G} written \funmt{Task}{I,G}=\bigoh{\accol{\varphi_0,\varphi_1,\ldots,\varphi_k}} if:
\begin{enumerate}
 \item any abstract robotic unit that is $K$-capable of \accol{\varphi_0,\varphi_1,\ldots,\varphi_k} in \funf{\calS}{I} can perform \funmt{Task}{I,G};
 \item some abstract robotic unit is $K$-capable of \accol{\varphi_0,\varphi_1,\ldots,\varphi_k} in \funf{\calS}{I}.
\end{enumerate}
\cite{conf/ijcai/BrafmanS95}
\end{defi}

\begin{defi}[Progress measure for an abstract robotic domain]
A \term{progress measure for an abstract robotic domain} \tuple{C,T} is a function \funsig{\rho}{\calC}{W}, where $W$ is a well-ordered set.
\cite{conf/ijcai/BrafmanS95}
\end{defi}

\begin{defi}
Given a task \funmt{Task}{I,G} and a knowledge-based protocol $\calP$, the function $\rho_{\calP,\funmt{Task}{I,G}}$ is defined for each $c\in\calC$ as the least upper bound on the number of steps along any execution of $V$ from initial configuration \accol{c} until the first time a configuration in $G$ is reached, or as if no such upper bound exists or if a configuration is reached on which $V$ is undefined. We say that $\tau\in\calT$ makes progress on $c\in\calC$ according to $\rho$ if for any $c'\in\fun{\calT}{c}\brak{c}$, $\fun{\rho}{c'}<\fun{\rho}{c}$.
\cite{conf/ijcai/BrafmanS95}
\end{defi}