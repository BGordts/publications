\chapter{Artificial Intelligence}

\section{First-Order Logic}

\begin{defi}[Signature]
$S$ is a \term{signature} if $S$ is a four-tuple \tuple{P,F,r,C} where:
\begin{enumerate}
\item $P$ is a set of \term{predicate symbols} \brak{P_1,P_2,\ldots,P_n},
\item $F$ is a set of \term{function symbols} \brak{F_1,F_2,\ldots,F_m},
\item $r$ is \term{arity} or \term{degree of functions} and relations. For each $P_i$ respectively $F_j$, \fun{r}{P_i} respectively \fun{r}{F_j} is a non-zero natural number denoting the arity of $P_i$ respectively $F_j$,
\item $C$ is a set of \term{constant symbols}.
\end{enumerate}
\cite{conf/fedcsis/Telnarova12}
\end{defi}

\begin{defi}[Alphabet]
An \term{alphabet} $\Sigma$ consists of the following symbols:
\begin{enumerate}
\item Signature $S=\tuple{P,F,r,C}$.
\item \term{Collection of variables} $V$.
\item \term{Operators}: $\neg$ (\term{negation}), $\wedge$ (\term{conjunction}), $\vee$ (\term{disjunction}), $\rightarrow$ (\term{implication}), $\leftrightarrow$ (\term{equivalence}).
\item \term{Quantifiers}: ï€¢$\forall$ (\term{forall}), $\exists$ (\term{exists}).
\item \term{Parentheses} and \term{punctuation symbols}: $($, $)$ and $,$.
\end{enumerate}
\cite{conf/fedcsis/Telnarova12}
\end{defi}

\begin{defi}[Term]
A \term{term} is defined inductively as follows:
\begin{enumerate}
\item Variable is term.
\item Constant is term.
\item If $f$ is a function symbol ($f\in F$) with arity $m$ and $t_1,t_2,\ldots,t_m$ are terms of $\Sigma$, then \ffun{t_1,t_2,\ldots,t_m} is term of $\Sigma$.
\end{enumerate}
\cite{conf/fedcsis/Telnarova12}
\end{defi}

\begin{defi}[Atom]
If $p$ is predicate symbol with arity $m$ and $t_1,t_2,\ldots,t_m$ are terms of $\Sigma$, then $\fun{p}{t_1,t_2,\ldots,t_m}$ is an \termor{atomic formula}{atom}. An atomic formula is a \term{formula} and all occurrences of variables in an atomic formula are free.
\cite{conf/fedcsis/Telnarova12}
\end{defi}

\begin{defi}[Formula]
A \term{formula} is defined as follows:
\begin{enumerate}
 \item An atom is a formula.
 \item If $H$ and $G$ are formulas, then:
 \begin{enumerate}
  \item $\neg H$ is a formula, the occurrence of variables in $\neg H$ is free respectively bound if it is free respectively bound in $H$,
  \item $H\wedge G$ is a formula, the occurrence of variables in $H\wedge G$ is free respectively bound if it is free respectively bound in $H$ or $G$,
  \item $H\vee G$ is a formula, the occurrence of variables in $H\vee G$ is free respectively bound if it is free respectively bound in $H$ or $G$,
  \item $H\rightarrow G$ is a formula, the occurrence of variables in $H\rightarrow G$ is free respectively bound if it is free respectively bound in $H$ or $G$,
  \item $H\leftrightarrow G$ is a formula, the occurrence of variables in $H\leftrightarrow G$ is free respectively bound if it is free respectively bound in $H$ or $G$.
 \end{enumerate}
 \item If $H$ is a formula and $x$ is a variable, then $\forall x:H$ and $\exists x:H$ are formulas. All occurrences of $x$ are bound.
\end{enumerate}
\cite{conf/fedcsis/Telnarova12}
\end{defi}

\begin{defi}[Literal]
A \term{literal} $L$ is an atom or the negation of an atom.
\cite{conf/fedcsis/Telnarova12}
\end{defi}

\begin{defi}[Clause]
A \term{clause} is a formula such as $\forall\vec{x}:L_1\vee L_2\vee\ldots\vee L_m$ where each $L_i$ is a literal and $\vec{x}=\brak{x_1,x_2,\ldots,x_n}$ are all the variables occurring in $L_1\vee L_2\vee\ldots\vee L_m$.
\cite{conf/fedcsis/Telnarova12}
\end{defi}

\begin{defi}[Horn-clauses]
\term{Horn-clause}s have the form: $\forall x_1,x_2,\ldots,x_n:L_1\wedge L_2\wedge\ldots\wedge L_m\rightarrow L$ where $L,L_1\wedge L_2\wedge\ldots\wedge L_m$ are a literals and $x_1,x_2,\ldots,x_n$ are all variables having free occurrences in $L,L_1\wedge L_2\wedge\ldots\wedge L_m$.
\cite{conf/fedcsis/Telnarova12}
\end{defi}

\section{Machine Learning and Probabilistic Reasoning}

\begin{defi}[Beliefs in Conjoint Analysis]
We allow weighted beliefs with a weight parameter coming from \ocinterval{0}{1} where $1$ means full truth degree (complete certainty, the perfect belief), while a value $\alpha\in\oointerval{0}{1}$ describe a regular belief that can be doubted.
\begin{enumerate}
 \item \term{Regular belief}s such as:
 \begin{equation}
(\fun{A_1}{a_1}\wedge\ldots\wedge\fun{A_t}{a_t}):\alpha
 \end{equation}
 \item \term{Indifference belief}s such as:
 \begin{equation}
 \left(L\leftrightarrow R\right):1
 \end{equation}
 Indifference beliefs are always have full truth because we claim that if the respondent would distinguish degrees of truth then she is able to express preference.
 \item \term{Negative belief}s such as:
 \begin{equation}
 \left(\neg F\right):1
 \end{equation}
\end{enumerate}
where $A_i$ are attribute predicates and $L$, $R$, $F$ are regular atom conjunctions. Again, it is obvious in conjoint to don't ask user to express thoughts on negative information. As such there are no real negative beliefs such as $F:0$. Moreover, the reader may notice that we adopt the intuitionistic logic approach i.e., there is no assumption on any kind of law of excluded middle, as we don't necessarily assume $F:0\Leftrightarrow\left(\neg F\right):1$.
\cite{conf/fedcsis/GiurcaSB12}
\end{defi}


\section{Optimization Problems}

\begin{defi}
A \term{neighborhood structure} is a function $\calN:\calS\rightarrow 2^\calS$ that assigns to every $s\in\calS$ a set of neighbors $\fun{\calN}{s}\subseteq\calS$. $\fun{\calN}{s}$ is called the neighborhood of $s$. Often, neighborhood structures are implicitly defined by specifying the changes that must be applied to a solution s in order to generate all its neighbors. The application of such an operator that produces a neighbor $s'\in\fun{\calN}{s}$ of a solution s is commonly called a \term{move}.\cite{alba05}
\end{defi}

\begin{defi}
A \term{locally minimal solution} (or \term{local minimum}) with respect to a neighborhood structure $\calN$ is a solution $\hat{s}$ such that $\forall s\in\neigh{\hat{s}}:\ffun{\hat{s}}\leq\ffun{s}$. We call $\hat{s}$ a \term{strict locally minimum} if $\forall s\in\neigh{\hat{s}}:\ffun{\hats}<\ffun{s}$.\cite{alba05}
\end{defi}