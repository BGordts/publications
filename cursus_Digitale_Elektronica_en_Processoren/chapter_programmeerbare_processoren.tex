\chapter{Programmeerbare Processoren}
\chapterquote{Mensen hebben met computers gemeen dat ze ook niets bereiken zonder goede programmeurs.}{Toon Verhoeven, Nederlands aforist (??-??)}
\begin{chapterintro}
In dit hoofdstuk bespreken we programmeerbare processoren. Deze processoren verschillen van de niet-programmeren processoren omdat een gebruiker een programma -- een reeks van instructies -- kan uitvoeren op de processor en bijgevolg in grote mate het algoritme die de processor uitvoert zelf kan bepalen. Centrale processoreenheden (CPU's) zijn hiervan slechts een subset van de programmeerbare processoren. We bespreken eerst de hoe een instructie eruitziet en hoe we een schakeling kunnen ontwerpen om deze instructies uit toe voeren. Cruciaal hierbij zijn de verschillende adresseermodi. Vervolgens beschouwen we de twee grote instructie-families: RISC en CISC. We zullen voor beide een instructieset ontwerpen en de verschillende aspecten die hierbij komen kijken bespreken.
\end{chapterintro}
\minitoc[n]
\section{De Programmeerbare Processor}
We zullen in deze sectie het verschil bespreken tussen een niet-programmeerbare processor (zie \chpref{nonprogramming}) en een programmeerbare processor. Algemeen is deze grens eerder vaag. Ook bij een niet programmeerbare processor zullen de controller en het datapad meestal be\"invloed worden door signalen van buiten de schakeling. Sommige technici kunnen door deze invoer te manipuleren de processor een algoritme laten uitvoeren waarvoor de schakeling niet ontworpen was.
\paragraph{}
Een duidelijke grens kunnen we trekken bij de controller. Bij conventie stellen we dat een processor niet-programmeerbaar is wanneer de schakeling wordt aangestuurd met een vaste controller. In het geval we dus een ander algoritme willen uitvoeren zullen we een ander controller moeten implementeren om het uit te voeren. Bij een programmeerbare processor dient men de controller niet aan te passen. De controller beschikt immers over een geheugen waarin het programma geladen kan worden. Door het geheugen aan te passen zal de controller het datapad anders aansturen waardoor een ander algoritme kan worden uitgevoerd. We kunnen dus stellen dat de eindige toestandsautomaat die in de controller werd ge\"implementeerd vast staat, onafhankelijk van het ingeladen programma. Het geheugen waaruit zo'n controller leest noemen we het \termen{programmageheugen}. De gegevens die van de controller naar dit geheugen stuurt worden het \termen{adres}, de \termen{programmateller} of de \termen{program counter (PC)} genoemd. De data van het programmageheugen naar de controller noemen we de \termen{instructie}.
\paragraph{}
Merk op dat de definitie hierbij geen concrete uitspraak doet over hoe een programma of instructie er precies dient uit te zien. De definitie impliceert bijvoorbeeld niet dat de processor elk te beschrijven algoritme moet kunnen uitvoeren. Hierbij kunnen we bijvoorbeeld denken aan een ``Graphical Processing Unit (GPU)''. Een GPU is een programmeerbare processor die gespecialiseerd is in grafische taken. De instructieset is dan ook eerder beperkt tot grafische operaties. Hoewel men dergelijk processoren meestal niet kan programmeren om bijvoorbeeld Dijkstra's algoritme uit te voeren, is de processor wel programmeerbaar.
\paragraph{}
\importtikzfigure{processor-programming}{De structuur van een programmeerbare processor.}
\figref{processor-programming} toont hoe een programmeerbare processor er in grote lijnen uitziet. Merk op dat het enige verschil tussen deze figuur en \figrefpag{processorInformationStreams} de introductie van een programmageheugen is.
\section{Instructies en Velden}
Nu we de structuur van een programmeerbare processor hebben voorgesteld, zullen we in deze sectie de verschillende aspecten en terminologie van een programma bespreken.
\subsection{Programma}
Een algemeen aanvaarde definitie voor een \termen{programma} is een sequentie van instructies. De instructies zijn op zo'n manier bepaald en geordend dat ze samen een complexe (en nuttige) taak uitvoeren. In dit opzicht bevat een sequentie van instructies dus dezelfde informatie als de eindige toestandsmachine van de controller bij een niet-programmeerbare processor.
\subsection{Instructie}
Een instructie is een reeks van bits die de informatie van \'e\'en toestand in het ASM-schema of \'e\'en toestand in de eindige toestandsautomaat van de controller voorstellen. Door pipelining kan een instructie of multicycling kan een instructie echter meerdere klokcycli duren. Dit kan men implementeren door bijvoorbeeld een andere volgende instructie te kiezen. Om een toestand voor te stellen zijn drie types informatie vereist:
\begin{itemize}
 \item De aansturing van het datapad: het bepalen van de stuursignalen naar de verschillende functionele eenheden, registers, tri-state buffers en multiplexers betrokken in het datapad.
 \item \termen{Data-uitwisseling}: sommige instructies bepalen welke informatie er ingeladen of weggeschreven wordt naar (externe) geheugens.
 \item De volgende instructie: de meeste algoritmes bevatten lussen en voorwaardelijke gedeeltes. Deze controle wordt ge\"implementeerd doordat de instructies (impliciet) bepalen wat de volgende instructie zal zijn.
\end{itemize}
Een instructie moet niet elk type informatie expliciet specificeren. We kunnen bijvoorbeeld denken aan het bepalen van de volgende toestand: meestal wordt een programma zo gestructureerd dat de volgende instructie bijna altijd op het volgende adres staat. In dat geval zullen enkel instructies die afwijken van deze regel dit moeten specificeren.
\paragraph{Notatie van een instructie}
Om instructies uit te drukken bestaan er twee typische notaties: de \termen{mnemonische notatie} en de \termen{actie-notatie}. In de mnemonische notatie specificeert men eerst de operatie gevolgd door het doel\footnote{De plaats waar het resultaat zal worden opgeslagen.} en de operanden. Verder worden zowel het doel en de operanden gespecificeerd aan de hand van adressen. Een typische instructie is bijgevolg \verb+add A B C+. Dit voorbeeld is een instructie uit de \verb+80x86+ instructieset. Mnemonische notatie wordt dan ook vaak gebruikt in assembleertalen (\verb+80x86+, ). Actie-notatie specificeert daarentegen eerst het doel, meestal gevolgd door bijvoorbeeld een pijl met daarna de functie en de operand. Een concreet voorbeeld van een instructie volgens deze notatie is \verb/Mem[A] <- Mem[B]+Mem[C]/. Actie-notatie is populair bij hardwarespecificatietalen.
\subsection{Instructieformaat}
De mnemonische notatie en de actie-notatie zijn manieren om instructies voor te stellen zodat ze leesbaar zijn voor mensen. In digitale logica wordt een instructie enkel voorgesteld door een sequentie aan bits. De ontwerper van een processor dient dan ook een \termen{instructieformaat} te specificeren: een beschrijving hoe een sequentie bits een instructie bepaald. Men kan dit formaat natuurlijk vrij bepalen, maar meestal beoogt men een structurele opbouw: de instructie wordt onderverdeeld in \termen{velden}: groepen van bits waar een betekenis of een subtaak aan wordt toegekend. In de meeste instructieformaten komen volgende velden voor:
\begin{itemize}
 \item \termen{Instructietype}: een groep bits die de klasse van de instructie aangeeft (bijvoorbeeld een sprongbevel, een bewerking, een geprivilegieerde instructie,...)
 \item \termen{Opcode} ofwel \termen{operation code}: een groep bits die de bewerking voorstellen (bijvoorbeeld een optelling, vermenigvuldiging,...)
 \item Adres: een groep bits die de locatie van een operand of een resultaat specificeert. Een adres hoeft echter niet beperkt te zijn tot de locatie in een (extern) geheugen: ook registers en registerbanken kunnen soms worden geadresseerd.
 \item \termen{Adresseermode}: een adresseermode bepaald hoe het adres gespecificeerd in bits wordt omgezet in een fysisch adres. Zo kan de adresseermode bijvoorbeeld bepalen dat het adres een register uit de registerbank specificeert of dat de adressen indirect\footnote{Bij indirecte adressering leest men de waarde van het geheugen uit op de gegeven locatie. Die waarde bepaald dan de locatie van de effectieve waarde.} moeten worden berekend.
 \item Constante: bewerkingen zoals een optelling tellen soms een constante op bij een register. In dat geval moet de constante in de instructie worden ingebed.
\end{itemize}
Men dient op te merken dat een veld niet noodzakelijk een vaste lengte heeft of slechts \'e\'enmaal voorkomt. Stel bijvoorbeeld dat de adresseermode bepaald dat de gegevens uit een registerbank moeten uitgelezen worden, verwachten we dat het adres korter zal zijn dan wanneer we het adres uit een RAM-geheugen halen. Verder zal men bij sommige operaties twee of meer operanden moeten selecteren. In dat geval is het dus mogelijk dat het adresveld meerdere keren voorkomt. Sommige processoren kunnen voorzien ook een instructieformaat waarbij men twee of meer bewerkingen kan specificeren die dan parallel worden uitgevoerd. In dat geval komt de opcode dus twee of meer keer voor.
\subsection{Generische Instructiecyclus}
Een processor voert een instructie doorgaans uit in vijf stappen. Deze stappen noemt men de generische instructiecyclus. De stappen zijn:
\begin{enumerate}
 \item Lees de instructie in: het programmageheugen wordt uitgelezen en de instructie wordt in het \termen{instructieregister (IR)} opgeslagen. De programmateller wordt verhoogt.
 \item Bereken de adressen: Op basis van de adresseermodi en de adressen in de instructie worden de echte adressen bepaald. Een adres uit een registerbank zal er dus anders uitzien dan een adres uit het RAM-geheugen.
 \item Lees de operanden: de adressen van de operanden worden uitgelezen en weggeschreven in tijdelijke registers.
 \item Voer de bewerking uit: op basis van de data in de operand-registers en de opcode kan men de relevante bewerking op de relevante data uitvoeren. Het resultaat wordt in een tijdelijk register geplaatst.
 \item Schrijf het resultaat weg: het resultaat wordt weggeschreven in een registerbank of RAM-geheugen (indien dit relevant is voor de bewerking).
\end{enumerate}
Deze cyclus wordt eindeloos herhaalt en leent zich meestal erg goed tot pipelining: enkel wanneer de volgende instructie een operand moet inlezen die bepaald wordt door een instructie die kort ervoor is uitgevoerd moet de pipeline worden onderbroken. Men kan een sprongbevel uitvoeren door in de instructie de programmateller aan te passen.
\subsection{Uitvoeringssnelheid}
De uitvoeringssnelheid van een instructie hangt in grote mate af van twee factoren:
\begin{itemize}
 \item De snelheid van het datapad
 \item Het aantal toegangen tot extern geheugen.
\end{itemize}
We kunnen de snelheid van het datapad doorgaans opdrijven door meer hardware te voorzien die bijvoorbeeld bewerkingen in parallel uitvoeren. Het aantal toegangen tot extern geheugen kunnen we dan weer verlagen door kleine en simpele instructies te voorzien waardoor met elk een beperkt aantal operaties op het geheugen.
\paragraph{}
De grootte van een instructie is echter een trade-off. Wanneer we grote instructies voorzien met een groot aantal bits laten we de programmeur toe om een complexe taak in zo'n instructie te specificeren. Bijgevolg verwachten we dat een programma uit een klein aantal van dergelijke instructies zal bestaan. Omdat de instructies echter complex zijn, verwachten we een traag datapad en veel geheugentoegangen. Wanneer de processor enkel simpele instructies aanbied kan het datapad deze snel uitvoeren, maar een programma zal een groot aantal instructies bevatten. De complexiteit van een instructieset wordt dan ook soms uitgedrukt in het aantal adresvelden.
\subsection{Adresvelden}
In deze subsectie zullen we enkele instructiesets bespreken volgens het aantal adresvelden. Bij de verschillende instructiesets zullen we aantal geheugentoegangen berekenen die nodig zijn om de volgende $\brak{a+b}\times\brak{a-b}$ uit te rekenen. Deze operatie wordt doorgaans niet als \'e\'en instructie aangeboden (tenzij bij processoren die taken uitvoeren waarbij deze bewerking zeer regelmatig zou voorkomen). We zullen dan ook uitgaan van een algemene instructieset die de optelling (\termen{Add-instructie}), aftrekking (\termen{Sub-instructie}) en vermenigvuldiging (\termen{Mul-instructie}) voorziet.
\paragraph{}
Alvorens we de instructiesets met elkaar kunnen vergelijken, zullen we eerst enkele aannames moeten maken over hoe gegevens en instructies kunnen worden ingelezen. We zullen uitgaan van een woordlengte\footnote{De woordlengte is het aantal bits die in een geheugen onder \'e\'en adres worden opgeslagen.} $w$. We maken de assumptie dat een instructie zonder geheugenadressen in \'e\'en woord\footnote{Een woord is een sequentie van $w$ bits met $w$ de woordlengte.} kan worden opgeslagen. Het geheugen omvat $2^w$ adressen, bijgevolg telt het geheugen $w\cdot 2^w$ bits en is elk adres voor te stellen met een woord. Een instructie met $k$ geheugenadressen kan dus worden opgeslagen in $k+1$ woorden. We vergelijken de instructiesets op basis van geheugentoegangen. Dit zijn dus het aantal toegangen om de instructie uit te lezen samen met het uitlezen en wegschrijven van gegevens die in de instructie worden gespecificeerd.
\subsubsection{Instructies met 3 adresvelden}
Een instructieset met drie adresvelden bepaald meestal \'e\'en adres voor het resultaat en twee adressen voor de operanden. Bijvoorbeeld de \verb+Add a b c+ instructie berekend de optelling van de gegeven die op de geheugenplaatsen $b$ en $c$ staan en plaatst het resultaat dus in adres $a$. Om $\brak{a+b}\times\brak{a-b}$ dus uit te rekenen zullen we volgend programma uitvoeren:
\begin{verbatim}
Add c a b
Sub x a b
Mul c c x
\end{verbatim}
Per instructie voorzien we dus $4+3$ geheugentoegangen. $4$ instructietoegangen per instructie $2$ leesoperaties voor de operanden en $1$ schrijfoperatie. Omdat we $3$ instructies uitvoeren vereist het programma dus $21$ geheugentoegangen. We kunnen echter opmerken dat in de laatste instructies we tweemaal hetzelfde adres vermelden. Dit soort instructies vormen dan ook de argumentatie om soms instructies met twee adresvelden te gebruiken.
\subsubsection{Instructies met 2 adresvelden}
Instructiesets met twee adresvelden zijn vrij populair. \verb+80x86+ is een voorbeeld van zo'n instructieset. In zo'n instructieset vertegenwoordigen het eerste en tweede adresveld de adressen van de operanden en het eerste veld ook het adres van het resultaat. Het eerste adres wordt bijgevolg overschreven.
\paragraph{}
Een probleem bij dit mechanisme is dat we soms na de bewerking de operanden willen kunnen hergebruiken om andere operaties uit te voeren. Zo willen we na het berekenen van $a+b$ nog over $a$ en $b$ kunnen beschikken om $a-b$ uit te rekenen. We kunnen de waarde kopi\"eren om dit probleem te vermijden. We kunnen de waarde van $x$ kopi\"eren naar adres $y$ met behulp van twee instructies: \verb+Sub y y+ en \verb+Add y x+. De meeste processoren voorzien echter een kopieer instructie: de \termen{Mov-instructie}. Het voordeel van deze instructie is dat naast het ophalen van de instructie slechts twee geheugentoegangen vereist zijn.
\paragraph{}
We kunnen het algoritme dan ook als volgt implementeren:
\begin{verbatim}
Mov c a
Add c b
Mov x a
Sub x b
Mul c x
\end{verbatim}
De Mov-instructie vereist in totaal $5$ geheugentoegangen, de overige instructies vereisen $6$ geheugentoegangen. In totaal vereist het uitvoeren van het algoritme dus $28$ geheugentoegangen. We dienen echter wel op te merken dat de instructies sneller zullen worden uitgevoerd.
\subsubsection{Instructies met 1 adresvelden}
We kunnen de instructieset verder reduceren tot \'e\'en adresveld per instructie. Dit doen we met behulp van een \termen{accumulator (ACC)}. Een accumulator is een speciaal register die dienst doet als zowel de eerste operand en het register waar het resultaat in wordt geplaatst. Men kan deze instructieset dus vergelijken met de eerste instructieset, maar waarbij de eerste operator altijd een vast adres voorstelt. Het voordeel van een accumulator is de implementatie door middel van een register: de accumulator inlezen of resultaten wegschrijven vereist bijgevolg geen geheugentoegang.
\paragraph{}
Ook wanneer we een accumulator gebruiken zullen we soms tussenresultaten tijdelijk in een andere variabele willen opslaan om de waarde later in te lezen. We kunnen hier geen gebruik maken van de Mov-instructie omdat het resultaat altijd vast staat: de accumulator. Daarom worden twee nieuwe instructies ge\"introduceerd: de \termen{Load-instructie} leest het adres uit en plaatst de waarde in de accumulator, de \termen{Store-instructie} schrijft de waarde van de accumulator weg in het opgegeven adres. De Store-instructie is bijgevolg een instructie waar de accumulator geen dienst doet als de ontvanger van het resultaat.
\paragraph{}
We kunnen het algoritme realiseren met volgende code:
\begin{verbatim}
Load a
Add b
Store x
Load a
Sub b
Mul x
Store c
\end{verbatim}
Elke instructie vereist telkens $3$ geheugentoegangen: $2$ om de instructie uit te lezen en $1$ geheugentoegang om het adres uit te lezen of de resultaten weg te schrijven. Omdat het algoritme in $7$ instructies kan worden ge\"implementeerd, zijn er in totaal $21$ geheugentoegangen vereist.
\subsubsection{Instructies zonder adresvelden}
Sommige instructiesets bevatten geen adressen als operanden. In een dergelijk systeem moeten we echter wel een systeem implementeren die zelf de adressen voorstelt.
\paragraph{}
Een populaire methode werkt met een stapelgeheugen. In zo'n systeem beschouwen we een stapel die groeit bij een een Load-instructie. Wanneer een instructie een berekening uitvoert worden de operanden uit de bovenste elementen van de stapel gehaald. Deze elementen worden van de stapel gehaald en het resultaat wordt vervolgens op de stapel gezet. Ook in een dergelijk systeem is er soms nood aan het opslaan van tussenresultaten om deze later te hergebruiken. Ook hiervoor gebruiken we de store operatie. De operatie neemt als argument een adres van de stapel: het aantal elementen onder de top. Ook dit kan men als een adres zien. Men maakt echter meestal de assumptie dat deze waarde niet buitengewoon groot is en de waarde dus in de instructie kan worden meegenomen. Bijgevolg bevat de instructie dus geen adres. Omdat het bovenste gedeelte van de stapel meestal met een registerbank wordt ge\"implementeerd, vereisen de bewerkingen bijgevolg geen geheugentoegangen.
\paragraph{}
We kunnen het algoritme implementeren met volgende instructies:
\begin{verbatim}
Load a
Load b
Add
Load a
Load b
Sub
Mul
Store c
\end{verbatim}
Om de impact te berekenen moeten we opnieuw een onderscheid maken tussen twee soorten instructies: Load- en Store instructies vereisen twee geheugentoegangen ($1$ geheugentoegang om de instructie op te halen en $1$ instructie om het resultaat op te halen of weg te schrijven) de overige instructies vereisen slechts \'e\'en geheugentoegang. In totaal vereist dit programma dus $13$ toegangen tot het geheugen.
\subsubsection{Instructies met registerbank-adressen: dubbele adressering}
Tot slot dienen we nog te vermelden dat een adresveld niet noodzakelijk altijd een geheugenadres moet omvatten. Men kan bijvoorbeeld een bit in dit veld voorzien die bepaald of het adres een geheugenadres specificeert of het adres van een registerbank. Daarnaast kan de interpretatie van een dergelijk adres ook afhangen van de instructie. Moderne processoren interpreteren bijvoorbeeld vaak de adressen bij bewerkingen als registerbank-adressen en de tweede operand bij een Load- of Store-instructie als een geheugenadres. Vermits een algoritme vooral met tussenresultaten zal rekenen verwachten we een tijdswinst omdat we niet telkens de operanden uit het geheugen moeten uitlezen.
\paragraph{}
Een dergelijke instructieset kan ook instructies met variabele lengte beschouwen. Sommige instructies omvatten immers geen geheugenadressen, andere wel. In dat geval kan de eerste instructie bijvoorbeeld aanleiding geven om het volgende woord in een instructieregister in te lezen, of de instructie meteen uit te voeren.
\paragraph{}
Registeradressen worden meestal voorgesteld met een prefix \verb+R+. In het geval van een dergelijke instructieset ziet het programma er als volgt uit:
\begin{verbatim}
Load R1 a
Load R2 b
Add R3 R1 R2
Sub R4 R1 R2
Mul R5 R3 R4
Store c R5
\end{verbatim}
Bewerking instructies worden voorgesteld in \'e\'en woord en vereisten geen extra geheugentoegang. Bijgevolg vereisen ze \'e\'en geheugentoegang. Load- en Store-bewerkingen vereisen $3$ geheugentoegangen: $2$ bij het inlezen van de instructie en $1$ bij het inlezen of wegschrijven van de data. In totaal vereist het programma dan ook $12$ keer toegang tot het geheugen.
\subsubsection{Besluit}
Er zijn verschillende instructiesets mogelijk met een verschillend aantal adresvelden. Instructies met een groot aantal adresvelden laten compacte programma's toe maar vereisen soms onnodig toegang tot het geheugen. Deze extra belasting komt in twee vormen: het inlezen van de adresvelden van de instructie en het uitlezen of wegschrijven van data in de vermelde geheugenadressen.
\paragraph{}
Een instructieset met minder adresvelden zal minder vaak onnodig toegang tot het geheugen aanvragen. Anderzijds wordt het programma langer waardoor de processor meer instructies uit het geheugen met uitlezen.
\subsection{Adresseermodi}
In de loop der jaren zijn er verschillende manieren ontwikkeld om een geheugenadres te bepalen op basis van een adresveld. Deze methodes noemen we adresseermodi. Adresseermodi hebben als primair doel het aantal bits te reduceren die het adresveld in beslag neemt. Anderzijds laten verschillende adresseermodi soms toe om meer te realiseren per instructie en dus tot compactere programma's te schrijven.
\paragraph{}
Ook in hogere programmeertalen maakt men impliciet gebruik van adresseermodi. We kunnen bijvoorbeeld denken aan arrays. Wanneer men in \verb+Java+ het tiende element van een array \verb+a+ wil uitlezen schrijf men \verb+a[10]+. Impliciet stelt men echter het adres die tien plaatsen verder dan het begin van het record voor \verb+a+ ligt. Adresseermodi kunnen programma's dus ook leesbaarder maken.
\subsubsection{Impliciete adressering}
\termen{Impliciete adressering} is een adresseermode waarbij een adresveld niet vermeld wordt in de instructie maar door de processor zelf kan worden berekend.
\paragraph{}
Dit is bijvoorbeeld het geval bij processoren met een stapelgeheugen. In een dergelijke instructieset worden de adressen afgeleid uit de toestand van de stapel: de bovenste elementen bevatten de data van de operanden. De processor rekent deze aspecten dus zelf uit.
\paragraph{}
Ook bij processoren die werken met een accumulator is dit het geval: men vermeld immers de bestemming van de data niet. Dergelijke processoren bieden meestal een instructie aan om de gegevens uit de accumulator te verwijderen: de \termen{CLRA-instructie}.
\subsubsection{Onmiddellijke adressering}
Behalve in het adresveld de plaats in het geheugen te specificeren waar de data moet worden opgehaald, kunnen we ook de data zelf opslaan in een adresveld. Deze vorm van adressering noemen we \termen{onmiddellijke adressering}. Dit is bijvoorbeeld het geval wanneer we werken met constanten.
\subsubsection{Directe adressering}
Meestal lezen we operanden uit met behulp van een adres. Dit adres verwijst ofwel naar een geheugenadres ofwel naar een index van een registerbank. In beide gevallen spreken we over \termen{directe adressering}. Het is meestal voordelig om een registerbank te gebruiken. Dit omwille van twee redenen: een registerbank bevat minder adressen en de toegang is sneller. Omdat een registerbank typisch $8$ tot $256$ register bijgevolg is de lengte van een registeradres tussen de $3$ en $8$ bits. Terwijl een geheugenadres typisch tussen de $32$ en $64$ bits lang is. We besparen dus ook tijd bij het inladen van de instructie.
\subsubsection{Indirecte adressering}
Soms kennen we de plaats waar de data in het geheugen staat niet expliciet. Stel bijvoorbeeld dat we werken met een heap\footnote{Een heap is een geheugenruimte waar men dynamisch record kan toevoegen en terug verwijderen.}, hangt de plaats waar de data staat meestal af van de manier hoe het programma eerder werd doorlopen. Het adres wordt dan ook ergens anders bewaard in het geheugen of een registerbank.
\paragraph{}
Indirecte adressering is een belangrijke vorm in programma's. Naast werken met een onbekend adres laat het ook toe het adres mee te geven wanneer we bijvoorbeeld een subroutine uitvoeren die een ``pointer'' vereist.
\paragraph{}
\termen{Indirecte adressering} maakt het mogelijk om in \'e\'en instructie de operand in te lezen waarvan het adres ergens in het geheugen staat. In dat geval dienen we dus het adres te specificeren waar het adres staat.
\begin{figure}[hbt]
\centering
\importtikzsubfigure{address-indirect}{Indirecte adressering}
\importtikzsubfigure{address-indirect-register}{Register-indirecte adressering}
\caption{Indirecte adressering}
\end{figure}
\paragraph{}
Tweemaal het geheugen uitlezen in \'e\'en instructie is echter een dure operatie. Daarom zal men de adressen doorgaans in een registerbank opslaan. In dat geval spreken we dan ook van \termen{register-indirecte adressering}.
\subsubsection{Relatieve adressering}
Hedendaagse besturingssystemen ondersteunen doorgaans multiprogramming: het tegelijk uitvoeren van verschillende programma's. Bijgevolg worden verschillende programma's tegelijk in het register geladen. De compiler van een programma weet doorgaans op voorhand niet waar het programma in het geheugen zal worden ingeladen. Wanneer een programma echter een sprongbevel uitvoert, moet het adres van het sprongbevel wijzen naar het correcte adres.
\paragraph{}
Het aangehaalde voorbeeld is \'e\'en van de redenen om \termen{relatieve adressering} toe te passen. Bij relatieve adressering houdt de processor een \termen{basisadres} bij in een impliciet register. Dit basisadres wordt bij het gegeven adres opgeteld om het werkelijke adres te bepalen. Het adresveld wordt in dat geval de \termen{offset} genoemd.
\begin{figure}[hbt]
\centering
\importtikzsubfigure{address-relative}{Relatieve adressering}
\importtikzsubfigure{address-relative-register}{Register-relatieve adressering}
\caption{Relatieve adressering}
\figlab{address-relative-general}
\end{figure}
\paragraph{}
Naast het verzekeren van correcte spronginstructies kan relatieve adressering ook tot kortere instructiewoorden leiden. We kunnen bijvoorbeeld een registerbank voorzien die verschillende basisadressen voorziet. De basisadressen kunnen bijvoorbeeld wijzen naar datastructuren die vaak gebruikt worden. Naast een veld die het register in de registerbank specificeert, dient men een veld te voorzien die de offset vanaf het basisadres voorstelt. Een dergelijke vorm van adressering noemen we \termen{register-relatieve adressering}.
\subsubsection{Ge\"indexeerde adressering}
We kunnen ook de twee velden omdraaien door het basisadres in de instructie onder te brengen en de offset in een impliciet register of een registerbank op te slaan. Deze vormen van adressering noemen we \termen{ge\"indexeerde adressering}. Ge\"indexeerde adressering is vooral interessant voor gegevensstructuren met eigen indexsystemen. We denken hierbij bijvoorbeeld aan arrays, matrices, stapels, wachtrijen,... In het register staat immers de index van de datastructuur zelf. Bij een array is dit bijvoorbeeld $i$ indien we het $i$-de element willen uitlezen.
\paragraph{}
\begin{figure}[hbt]
\centering
\importtikzsubfigure{address-indexed}{Ge\"indexeerde adressering}
\importtikzsubfigure{address-indexed-register}{Register-ge\"indexeerde adressering}
\caption{Ge\"indexeerde adressering}
\figlab{address-indexed-general}
\end{figure}
De structuur van ge\"indexeerde adressen op \figref{address-indexed-general} lijkt sterk op de structuur van relatieve adressen op \figref{address-relative-general}. Het verschil is echter dat een basisadres een volwaardig adres is en dus makkelijk $32$ bits telt. De offset daarentegen telt doorgaans slechts $3$ tot $8$ bits. Bij ge\"indexeerde adressering zijn de instructies dus groter.
\paragraph{}
Ook bij deze vorm van adressering kunnen we gebruik maken van een register bank. In dat geval wordt het adres van de registerbank bepaald door een veld in de instructie. Uit dit adres wordt dan de offset opgeslagen in registerbank berekend. Deze vorm van adressering noemen we naar analogie \termen{register-ge\"indexeerde adressering}.
\subsubsection{Ge\"indexeerde adressering met autoincrement/autodecrement}
Meestal leest men een bepaald element uit een array, matrix,... uit binnen een lus in het programma. De meeste programma's zullen dan ook de volledige array of een significant deel overlopen. Dit gebeurd doorgaans in een logische volgorde van links naar rechts of omgekeerd. Men kan het mechanisme achter ge\"indexeerde adressering uitbreiden met \termen{autoincrement} en/of \termen{autodecrement}. Wanneer we deze adresseringmode toepassen wordt het impliciete register die de offset bijhoudt na het uitvoeren van de opdracht automatisch opgehoogd of verlaagd. Hierdoor kan men bij een volgende instructie meteen het volgende of vorige element in de array uitlezen zonder eerst zelf manueel het register op te hogen. Dit kan voordelig zijn omdat het uitrekenen van de nieuwe waarde voor het offset-register parallel kan gebeuren met het uitvoeren van de instructie zelf.
\paragraph{}
\importtikzfigure{address-index-increment}{Ge\"indexeerde adressering met autoincrement/autodecrement.}
\figref{address-index-increment} illustreert het principe. Op basis van de een de instructie kiest men welke waarde door de multiplexer stroomt, deze waarde wordt bij de originele offset opgeteld en vervolgens in het register ingeladen. Door dezelfde instructie vervolgens daarna uit te voeren, zullen we een ander geheugenadres uitlezen bij het bepalen van de operand.
\paragraph{}
Soms bestaat een array niet uit bytes maar uit bijvoorbeeld long integers (8 bytes). Bij sommige processoren kan men dan ook de staplengte bepalen door deze in een veld in de instructie te specificeren, of weg te schrijven in een speciaal hiervoor bestemd register.
\section{Processorontwerp}
Nu we de belangrijkste aspecten van een instructieset hebben besproken, zullen we het ontwerp van de processor zelf in detail bespreken. We zullen eerst de algemene ontwerpcyclus waarna we het ontwerp bespreken voor de twee grote families van instructiesets: CISC en RISC.
\subsection{RISC en CISC}
In de vorige sectie werden instructiesets vergeleken volgens het aantal adresvelden per instructie. Het aantal adresvelden vormt dan ook de belangrijkste basis om instructiesets in te delen in \'e\'en van de twee families: de \termen{Complex Instruction Set Computer (CISC)} of \termen{Reduced Instruction Set Computer (RISC)}.
\subsubsection{CISC}
In het geval van CISC beschouwt men een grote instructieset met complexe en trage instructies. De instructieset omvat meestal een groot aantal verschillende operaties waarbij men ook een groot aantal adresseermodi voorziet. Dit leidt meestal tot een complex datapad met veel functionele eenheden registers en complexe verbindingen die de datastroom controleren. Het gevolg is dat dergelijke processoren aan een lage klokfrequentie werken. De programma's zijn echter vrij kort en men hoopt meestal snelheidswinst te boeken door de operaties die worden uitgevoerd bij een operatie in parallel op het datapad uit te voeren. Typische CISC instructiesets zijn \verb+System/360+, \verb+PDP-11+, \verb+VAX+, \verb+Motorola 68k+ en \verb+80x86+.
\subsubsection{RISC}
Een RISC processor omvat een kleine instructieset die uit een klein aantal eenvoudige instructies bestaat. Een instructie omvat hoogstens \'e\'en adresveld en meestal zijn slechts enkele adresmodi beschikbaar. Een eenvoudige instructieset leidt echter tot een eenvoudig datapad waardoor men een hoge kloksnelheid kan aanbieden. De programma's zijn vrij lang maar men hoopt meestal om hierdoor neven-operaties die soms ongewild worden uitgevoerd op een CISC processor te vermijden. Typische RISC instructiesets zijn \verb+DEC Alpha+, \verb+ARM+, \verb+SPARC+, en \verb+MIPS+.
\subsubsection{Evolutie}
Men merkt dat er een evolutie is van CISC processoren naar RISC processoren. Deze evolutie werd vooral gepromoot door onderzoek bij IBM die aantoonde dat meestal een beperkte subset van de aangeboden instructies effectief door programma's werd gebruikt. Dit effect werd ook versterkt door de komst van compilers die er meestal niet in slagen alle aspecten van een CISC instructieset automatisch uit te buiten. Andere aspecten die voor het gebruik van RISC processoren pleiten zijn de grootte van de chip, de energieconsumptie en de kostprijs.
\subsection{Ontwerpcyclus}
\importtikzfigure{processor-design-cycle}{De processorontwerp-cyclus.}
\figref{processor-design-cycle} beschrijft de vijf fases bij het ontwerpen van een processor:
\begin{enumerate}
 \item Ontwerp van de instructiecyclus: in deze fase stelt men een set van mogelijke instructies, meestal gaan de instructies gepaard met een informele beschrijving van het effect van de instructie.
 \item Instructieset-stroomschema: in deze fases worden per instructie alle betrokken operaties beschreven. De meeste instructies zullen immers verschillende effecten teweegbrengen. Bij de \verb+80x86+-instructieset zal bijvoorbeeld naast de bewerking ook de programmateller worden opgehoogd en zullen bepaalde registers op basis van het resultaat worden aangepast.
 \item Allocatie van het datapad: op basis van de vereiste bewerkingen kunnen we bepalen welke componenten we in het datapad zullen moeten voorzien. Dit omvat een beschrijving van de vereiste registers en functionele eenheden. Indien dit tot een duur datapad leidt kan men beslissen om de instructieset opnieuw te herbekijken. En begint men dus terug met fase 1.
 \item Op basis van de beschikbare datapad componenten kan men een ASM-schema opstellen. Doorgaans wordt een instructie niet in \'e\'en klokcyclus uitgevoerd. De verschillenden vereiste operaties worden dus uitgevoerd in verschillende toestanden in het ASM-schema. Dit schema beschrijft dan ook de verschillende registertransfers per klokcyclus.
 \item Ontwerp van de controller en het datapad: op basis van het ASM-schema kunnen we vervolgens een datapad en controller synthetiseren. De methodologie van deze synthese staat beschreven in \chpref{nonprogramming}.
\end{enumerate}
\subsection{Complex Instruction Set Computer (CISC)}
In deze subsectie zullen we het proces doorlopen bij het ontwerpen van een CISC processor.
\subsubsection{Ontwerp Instructieset}
In de eerste stap zullen we een CISC instructieset bepalen. We bepalen eerst de specificaties van het geheugen waarmee de processor werkt. Bij wijze van voorbeeld zullen we een $2^{16}\times 16$-bit geheugen beschouwen. De woordlengte is dus $16$ bit en elk adres kan voorgesteld worden met behulp van $16$ bits. We beschouwen ook een registerbank met $8$ registers. Elk registeradres kan dus voorgesteld worden met $3$ bits.
\paragraph{}
Uit de specificaties van het geheugen kunnen we afleiden dat een adresveld bij voorkeur ook $16$ bit groot is. De rest van de instructie zullen we ook voorstellen met behulp van $16$ bit. We beschouwen vier verschillende types van instructies:
\begin{enumerate}
 \item \termen{Registerinstructies}: instructies die bewerkingen uitvoeren met $1$ of $2$ operanden en $1$ doelregister.
 \item \termen{Verplaatsinstructies}: instructies die de gegevens van een register of geheugenadres kopi\"eren naar een register of geheugenadres.
 \item \termen{Spronginstructies}: instructies die de programmateller aanpassen. Deze instructies bepalen bijgevolg het verloop van het programma.
 \item Overige instructies: dit zijn instructies zoals \termen{No Operation (NOP)}\footnote{De ``No Operation'' is een instructie die geen effect heeft. Deze instructie wordt gebruikt bij pipelining om ruimte op te vullen in de pipeline zodat instructies kunnen wachten tot andere instructies zijn uitgevoerd.}.
\end{enumerate}
We voorzien in een instructie dan ook twee bits om het type voor te stellen. De instructies vereisen hoogstens drie registers. In elke registers zullen we daarom drie velden van telkens $3$ bits voorzien om het doelregister -- \mbox{Bestemming} -- en de twee operandregisters \mbox{Operand 1} en \mbox{Operand 2} voor te stellen. Vermits een instructie $16$ bits telt en we in totaal reeds $11$ bits hebben toegewezen, blijven er $5$ bits over voor de opcode. We hebben bijgevolg een instructieformaat gedefinieerd zoals weergegeven op \figref{cisc-bitstructure-general}.
\importtikzfigure{cisc-bitstructure-general}{De bitstructuur van de CISC instructieset.}
\paragraph{}
Het type en de opcode bepalen samen welke instructie zal worden uitgevoerd. We dienen echter nog bewerkingen toe te kennen aan de verschillende waardes. Hiervoor voorzien we \tblrefs{cisc-registerinstructions,cisc-moveinstructions,cisc-jumpinstructions,cisc-otherinstructions} die de instructies per type beschrijven.
\paragraph{Registerinstructies}
\importtabulartable{cisc-registerinstructions}{De registerinstructies van de CISC-processor (type $00$).}
De registerinstructies worden allemaal uitgevoerd op registeradressen en worden opgedeeld in drie categorie\"en: aritmetische, logische en schuifoperaties. De categorie\"en worden bepaald door de eerste twee bits: wanneer $o_4$ laag is beschouwen we een schuifoperaties, in het andere geval beschouwen we ofwel een aritmetische of logische operatie. Bij een schuifoperatie bepaald $o_3$ of we naar links of naar rechts schuiven. De overige drie bits bepalen vervolgens het aantal bits waarover we schuiven. In het andere geval bepaald $o_3$ of we aritmetische (laag) of logische operatie (hoog beschouwen). We delen de aritmetische operaties verder op in optelling/aftrekking-bewerkingen en vermenigvuldiging/deling operaties. $o_2$ deelt de operaties verder in zodat bij bewerkingen met twee operanden $o_1$ laag is en we in het andere geval bewerkingen met \'e\'en operand beschouwen. We beschouwen volgende operaties: optelling, aftrekking, increment, decrement, vermenigvuldiging, deling, \termen{vierkantswortel} en negatie. In het geval van logische bewerkingen bepalen de overige drie bits welke operatie we uitvoeren: AND, NAND, OR, NOR, XOR, XNOR, \termen{mask} en invert. De verschillende instructies worden voorgesteld in \tblref{cisc-registerinstructions} samen met een formele beschrijving van de bewerking.
\paragraph{Verplaatsinstructies}
\importtabulartable{cisc-moveinstructions}{De verplaatsinstructies van de CISC-processor (type $01$).}
Verplaatsinstructies zijn instructies die gegevens tussen het geheugen en de registerbank kopi\"eren. Er zijn in dit geval slechts twee basisinstructies mogelijk: kopi\"eren naar het geheugen (\termen{store}) of kopi\"eren naar de registerbank (\termen{load}). We bepalen dit met behulp van de eerste bit $o_0$. Met de overige vier bits kunnen we vervolgens de adresseermode bepalen. De eerste bit van de adresmodus bepaald of de instructie een adresveld voorziet. Dit is nuttig omdat de hardware snel moet kunnen beslissen of dit adresveld ook moet worden uitgelezen. Indien $m_3$ dus laag is maken we gebruik van een adresveld, in het andere geval kan men het adres afleiden uit de gegevens in de registervelden. De overige bits bepalen vervolgens de soort adressering: onmiddellijk ($000$), direct ($001$), indirect ($010$), relatief ($011$), ge\"indexeerd ($100$) en registerkopie ($101$). Afhankelijk van het feit of we een adresveld beschouwen is de adressering dan bijvoorbeeld relatief of register-relatief. Verder zijn sommige combinaties niet mogelijk: we kunnen bijvoorbeeld onmogelijk de waarde van een register naar een constante kopi\"eren wanneer we onmiddellijke adressering zouden gebruiken. Wanneer we de verschillende mogelijkheden uitproberen bekomen we de instructieset in \tblref{cisc-moveinstructions}.
\paragraph{Spronginstructies}
\importtabulartable{cisc-jumpinstructions}{De spronginstructies van de CISC-processor (type $10$).}
Doorgaans beschouwd men vier verschillende soorten sprongbevelen:
\begin{itemize}
 \item \termen{Ongeconditioneerde sprong (JMP)}: in dit geval wordt de programmateller gezet op het opgegeven adres.
 \item \termen{Geconditioneerde sprong (CJMP)}: dit is een spronginstructie die enkel wordt uitgevoerd als aan een bepaalde voorwaarde wordt voldaan. Hiervoor houdt de processor een \termen{statusregister} bij. Sommige instructies die we verder zullen beschouwen kunnen op basis van een bepaalde voorwaarde een $0$ of een $1$ naar dat register schrijven. Enkel wanneer het statusregister op $1$ staat wordt de programmateller op het opgegeven adres gezet. In het andere geval wordt de programmateller opgehoogd.
 \item \termen{Subroutine sprong (JSR)}: 
\end{itemize}
\paragraph{Overige instructies}
\importtabulartable{cisc-otherinstructions}{De overige instructies van de CISC-processor (type $11$).}
\subsubsection{Instructieset-stroomschema}
\subsubsection{Allocatie datapadcomponenten}
\subsubsection{ASM-schema}
\subsubsection{Ontwerp Controller}
\subsubsection{Ontwerp Datapad}
\subsection{Reduced Instruction Set Computer (RISC)}
\subsubsection{Ontwerp Instructieset}
\subsubsection{Instructieset-stroomschema}
\subsubsection{Allocatie datapadcomponenten}
\subsubsection{ASM-schema}
\subsubsection{Ontwerp Controller}
\subsubsection{Ontwerp Datapad}