\chapter{Programmeerbare Processoren}
\chapterquote{Mensen hebben met computers gemeen dat ze ook niets bereiken zonder goede programmeurs.}{Toon Verhoeven, Nederlands aforist (??-??)}
\begin{chapterintro}
In dit hoofdstuk bespreken we programmeerbare processoren. Deze processoren verschillen van de niet-programmeren processoren omdat een gebruiker een programma -- een reeks van instructies -- kan uitvoeren op de processor en bijgevolg in grote mate het algoritme die de processor uitvoert zelf kan bepalen. Centrale processoreenheden (CPU's) zijn hiervan slechts een subset van de programmeerbare processoren. We bespreken eerst de hoe een instructie eruitziet en hoe we een schakeling kunnen ontwerpen om deze instructies uit toe voeren. Cruciaal hierbij zijn de verschillende adresseermodi. Vervolgens beschouwen we de twee grote instructie-families: RISC en CISC. We zullen voor beide een instructieset ontwerpen en de verschillende aspecten die hierbij komen kijken bespreken.
\end{chapterintro}
\section{De Programmeerbare Processor}
We zullen in deze sectie het verschil bespreken tussen een niet-programmeerbare processor (zie \chpref{nonprogramming}) en een programmeerbare processor. Algemeen is deze grens eerder vaag. Ook bij een niet programmeerbare processor zullen de controller en het datapad meestal be\"invloed worden door signalen van buiten de schakeling. Sommige technici kunnen door deze invoer te manipuleren de processor een algoritme laten uitvoeren waarvoor de schakeling niet ontworpen was.
\paragraph{}
Een duidelijke grens kunnen we trekken bij de controller. Bij conventie stellen we dat een processor niet-programmeerbaar is wanneer de schakeling wordt aangestuurd met een vaste controller. In het geval we dus een ander algoritme willen uitvoeren zullen we een ander controller moeten implementeren om het uit te voeren. Bij een programmeerbare processor dient men de controller niet aan te passen. De controller beschikt immers over een geheugen waarin het programma geladen kan worden. Door het geheugen aan te passen zal de controller het datapad anders aansturen waardoor een ander algoritme kan worden uitgevoerd. We kunnen dus stellen dat de eindige toestandsautomaat die in de controller werd ge\"implementeerd vast staat, onafhankelijk van het ingeladen programma. Het geheugen waaruit zo'n controller leest noemen we het \termen{programmageheugen}. De gegevens die van de controller naar dit geheugen stuurt worden het \termen{adres}, de \termen{programmateller} of de \termen{program counter (PC)} genoemd. De data van het programmageheugen naar de controller noemen we de \termen{instructie}.
\paragraph{}
Merk op dat de definitie hierbij geen concrete uitspraak doet over hoe een programma of instructie er precies dient uit te zien. De definitie impliceert bijvoorbeeld niet dat de processor elk te beschrijven algoritme moet kunnen uitvoeren. Hierbij kunnen we bijvoorbeeld denken aan een ``Graphical Processing Unit (GPU)''. Een GPU is een programmeerbare processor die gespecialiseerd is in grafische taken. De instructieset is dan ook eerder beperkt tot grafische operaties. Hoewel men dergelijk processoren meestal niet kan programmeren om bijvoorbeeld Dijkstra's algoritme uit te voeren, is de processor wel programmeerbaar.
\paragraph{}
\importtikzfigure{processor-programming}{De structuur van een programmeerbare processor.}
\figref{processor-programming} toont hoe een programmeerbare processor er in grote lijnen uitziet. Merk op dat het enige verschil tussen deze figuur en \figrefpag{processorInformationStreams} de introductie van een programmageheugen is.
\section{Programma als een Reeks Instructies}
Nu we de structuur van een programmeerbare processor hebben voorgesteld, zullen we in deze sectie de verschillende aspecten en terminologie van een programma bespreken.
\subsection{Programma}
Een algemeen aanvaarde definitie voor een \termen{programma} is een sequentie van instructies. De instructies zijn op zo'n manier bepaald en geordend dat ze samen een complexe (en nuttige) taak uitvoeren. In dit opzicht bevat een sequentie van instructies dus dezelfde informatie als de eindige toestandsmachine van de controller bij een niet-programmeerbare processor.
\subsection{Instructie}
Een instructie is een reeks van bits die de informatie van \'e\'en toestand in het ASM-schema of \'e\'en toestand in de eindige toestandsautomaat van de controller voorstellen. Door pipelining kan een instructie of multicycling kan een instructie echter meerdere klokcycli duren. Dit kan men implementeren door bijvoorbeeld een andere volgende instructie te kiezen. Om een toestand voor te stellen zijn drie types informatie vereist:
\begin{itemize}
 \item De aansturing van het datapad: het bepalen van de stuursignalen naar de verschillende functionele eenheden, registers, tri-state buffers en multiplexers betrokken in het datapad.
 \item \termen{Data-uitwisseling}: sommige instructies bepalen welke informatie er ingeladen of weggeschreven wordt naar (externe) geheugens.
 \item De volgende instructie: de meeste algoritmes bevatten lussen en voorwaardelijke gedeeltes. Deze controle wordt ge\"implementeerd doordat de instructies (impliciet) bepalen wat de volgende instructie zal zijn.
\end{itemize}
Een instructie moet niet elk type informatie expliciet specificeren. We kunnen bijvoorbeeld denken aan het bepalen van de volgende toestand: meestal wordt een programma zo gestructureerd dat de volgende instructie bijna altijd op het volgende adres staat. In dat geval zullen enkel instructies die afwijken van deze regel dit moeten specificeren.
\paragraph{Notatie van een instructie}
Om instructies uit te drukken bestaan er twee typische notaties: de \termen{mnemonische notatie} en de \termen{actie-notatie}. In de mnemonische notatie specificeert men eerst de operatie gevolgd door het doel\footnote{De plaats waar het resultaat zal worden opgeslagen.} en de operanden. Verder worden zowel het doel en de operanden gespecificeerd aan de hand van adressen. Een typische instructie is bijgevolg \verb+add A B C+. Dit voorbeeld is een instructie uit de \verb+80x86+ instructieset. Mnemonische notatie wordt dan ook vaak gebruikt in assembleertalen (\verb+80x86+, ). Actie-notatie specificeert daarentegen eerst het doel, meestal gevolgd door bijvoorbeeld een pijl met daarna de functie en de operand. Een concreet voorbeeld van een instructie volgens deze notatie is \verb/Mem[A] <- Mem[B]+Mem[C]/. Actie-notatie is populair bij hardwarespecificatietalen.
\subsection{Instructieformaat}
De mnemonische notatie en de actie-notatie zijn manieren om instructies voor te stellen zodat ze leesbaar zijn voor mensen. In digitale logica wordt een instructie enkel voorgesteld door een sequentie aan bits. De ontwerper van een processor dient dan ook een \termen{instructieformaat} te specificeren: een beschrijving hoe een sequentie bits een instructie bepaald. Men kan dit formaat natuurlijk vrij bepalen, maar meestal beoogt men een structurele opbouw: de instructie wordt onderverdeeld in \termen{velden}: groepen van bits waar een betekenis of een subtaak aan wordt toegekend. In de meeste instructieformaten komen volgende velden voor:
\begin{itemize}
 \item \termen{Instructietype}: een groep bits die de klasse van de instructie aangeeft (bijvoorbeeld een sprongbevel, een bewerking, een geprivilegieerde instructie,...)
 \item \termen{Opcode} ofwel \termen{operation code}: een groep bits die de bewerking voorstellen (bijvoorbeeld een optelling, vermenigvuldiging,...)
 \item Adres: een groep bits die de locatie van een operand of een resultaat specificeert. Een adres hoeft echter niet beperkt te zijn tot de locatie in een (extern) geheugen: ook registers en registerbanken kunnen soms worden geadresseerd.
 \item \termen{Adresseermode}: een adresseermode bepaald hoe het adres gespecificeerd in bits wordt omgezet in een fysisch adres. Zo kan de adresseermode bijvoorbeeld bepalen dat het adres een register uit de registerbank specificeert of dat de adressen indirect\footnote{Bij indirecte adressering leest men de waarde van het geheugen uit op de gegeven locatie. Die waarde bepaald dan de locatie van de effectieve waarde.} moeten worden berekend.
 \item Constante: bewerkingen zoals een optelling tellen soms een constante op bij een register. In dat geval moet de constante in de instructie worden ingebed.
\end{itemize}
Men dient op te merken dat een veld niet noodzakelijk een vaste lengte heeft of slechts \'e\'enmaal voorkomt. Stel bijvoorbeeld dat de adresseermode bepaald dat de gegevens uit een registerbank moeten uitgelezen worden, verwachten we dat het adres korter zal zijn dan wanneer we het adres uit een RAM-geheugen halen. Verder zal men bij sommige operaties twee of meer operanden moeten selecteren. In dat geval is het dus mogelijk dat het adresveld meerdere keren voorkomt. Sommige processoren kunnen voorzien ook een instructieformaat waarbij men twee of meer bewerkingen kan specificeren die dan parallel worden uitgevoerd. In dat geval komt de opcode dus twee of meer keer voor.
\section{Processorontwerp}
\subsection{Complex Instruction Set Computer (CISC)}
\subsection{Reduced Instruction Set Computer (RISC)}