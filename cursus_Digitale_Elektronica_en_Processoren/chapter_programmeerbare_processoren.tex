\chapter{Programmeerbare Processoren}
\chapterquote{Mensen hebben met computers gemeen dat ze ook niets bereiken zonder goede programmeurs.}{Toon Verhoeven, Nederlands aforist (??-??)}
\begin{chapterintro}
In dit hoofdstuk bespreken we programmeerbare processoren. Deze processoren verschillen van de niet-programmeren processoren omdat een gebruiker een programma -- een reeks van instructies -- kan uitvoeren op de processor en bijgevolg in grote mate het algoritme die de processor uitvoert zelf kan bepalen. Centrale processoreenheden (CPU's) zijn hiervan slechts een subset van de programmeerbare processoren. We bespreken eerst de hoe een instructie eruitziet en hoe we een schakeling kunnen ontwerpen om deze instructies uit toe voeren. Cruciaal hierbij zijn de verschillende adresseermodi. Vervolgens beschouwen we de twee grote instructie-families: RISC en CISC. We zullen voor beide een instructieset ontwerpen en de verschillende aspecten die hierbij komen kijken bespreken.
\end{chapterintro}
\minitoc[n]
\section{De Programmeerbare Processor}
We zullen in deze sectie het verschil bespreken tussen een niet-programmeerbare processor (zie \chpref{nonprogramming}) en een programmeerbare processor. Algemeen is deze grens eerder vaag. Ook bij een niet programmeerbare processor zullen de controller en het datapad meestal be\"invloed worden door signalen van buiten de schakeling. Sommige technici kunnen door deze invoer te manipuleren de processor een algoritme laten uitvoeren waarvoor de schakeling niet ontworpen was.
\paragraph{}
Een duidelijke grens kunnen we trekken bij de controller. Bij conventie stellen we dat een processor niet-programmeerbaar is wanneer de schakeling wordt aangestuurd met een vaste controller. In het geval we dus een ander algoritme willen uitvoeren zullen we een ander controller moeten implementeren om het uit te voeren. Bij een programmeerbare processor dient men de controller niet aan te passen. De controller beschikt immers over een geheugen waarin het programma geladen kan worden. Door het geheugen aan te passen zal de controller het datapad anders aansturen waardoor een ander algoritme kan worden uitgevoerd. We kunnen dus stellen dat de eindige toestandsautomaat die in de controller werd ge\"implementeerd vast staat, onafhankelijk van het ingeladen programma. Het geheugen waaruit zo'n controller leest noemen we het \termen{programmageheugen}. De gegevens die van de controller naar dit geheugen stuurt worden het \termen{adres}, de \termen{programmateller} of de \termen{program counter (PC)} genoemd. De data van het programmageheugen naar de controller noemen we de \termen{instructie}.
\paragraph{}
Merk op dat de definitie hierbij geen concrete uitspraak doet over hoe een programma of instructie er precies dient uit te zien. De definitie impliceert bijvoorbeeld niet dat de processor elk te beschrijven algoritme moet kunnen uitvoeren. Hierbij kunnen we bijvoorbeeld denken aan een ``Graphical Processing Unit (GPU)''. Een GPU is een programmeerbare processor die gespecialiseerd is in grafische taken. De instructieset is dan ook eerder beperkt tot grafische operaties. Hoewel men dergelijk processoren meestal niet kan programmeren om bijvoorbeeld Dijkstra's algoritme uit te voeren, is de processor wel programmeerbaar.
\paragraph{}
\importtikzfigure{processor-programming}{De structuur van een programmeerbare processor.}
\figref{processor-programming} toont hoe een programmeerbare processor er in grote lijnen uitziet. Merk op dat het enige verschil tussen deze figuur en \figrefpag{processorInformationStreams} de introductie van een programmageheugen is.
\section{Programma als een Reeks Instructies}
Nu we de structuur van een programmeerbare processor hebben voorgesteld, zullen we in deze sectie de verschillende aspecten en terminologie van een programma bespreken.
\subsection{Programma}
Een algemeen aanvaarde definitie voor een \termen{programma} is een sequentie van instructies. De instructies zijn op zo'n manier bepaald en geordend dat ze samen een complexe (en nuttige) taak uitvoeren. In dit opzicht bevat een sequentie van instructies dus dezelfde informatie als de eindige toestandsmachine van de controller bij een niet-programmeerbare processor.
\subsection{Instructie}
Een instructie is een reeks van bits die de informatie van \'e\'en toestand in het ASM-schema of \'e\'en toestand in de eindige toestandsautomaat van de controller voorstellen. Door pipelining kan een instructie of multicycling kan een instructie echter meerdere klokcycli duren. Dit kan men implementeren door bijvoorbeeld een andere volgende instructie te kiezen. Om een toestand voor te stellen zijn drie types informatie vereist:
\begin{itemize}
 \item De aansturing van het datapad: het bepalen van de stuursignalen naar de verschillende functionele eenheden, registers, tri-state buffers en multiplexers betrokken in het datapad.
 \item \termen{Data-uitwisseling}: sommige instructies bepalen welke informatie er ingeladen of weggeschreven wordt naar (externe) geheugens.
 \item De volgende instructie: de meeste algoritmes bevatten lussen en voorwaardelijke gedeeltes. Deze controle wordt ge\"implementeerd doordat de instructies (impliciet) bepalen wat de volgende instructie zal zijn.
\end{itemize}
Een instructie moet niet elk type informatie expliciet specificeren. We kunnen bijvoorbeeld denken aan het bepalen van de volgende toestand: meestal wordt een programma zo gestructureerd dat de volgende instructie bijna altijd op het volgende adres staat. In dat geval zullen enkel instructies die afwijken van deze regel dit moeten specificeren.
\paragraph{Notatie van een instructie}
Om instructies uit te drukken bestaan er twee typische notaties: de \termen{mnemonische notatie} en de \termen{actie-notatie}. In de mnemonische notatie specificeert men eerst de operatie gevolgd door het doel\footnote{De plaats waar het resultaat zal worden opgeslagen.} en de operanden. Verder worden zowel het doel en de operanden gespecificeerd aan de hand van adressen. Een typische instructie is bijgevolg \verb+add A B C+. Dit voorbeeld is een instructie uit de \verb+80x86+ instructieset. Mnemonische notatie wordt dan ook vaak gebruikt in assembleertalen (\verb+80x86+, ). Actie-notatie specificeert daarentegen eerst het doel, meestal gevolgd door bijvoorbeeld een pijl met daarna de functie en de operand. Een concreet voorbeeld van een instructie volgens deze notatie is \verb/Mem[A] <- Mem[B]+Mem[C]/. Actie-notatie is populair bij hardwarespecificatietalen.
\subsection{Instructieformaat}
De mnemonische notatie en de actie-notatie zijn manieren om instructies voor te stellen zodat ze leesbaar zijn voor mensen. In digitale logica wordt een instructie enkel voorgesteld door een sequentie aan bits. De ontwerper van een processor dient dan ook een \termen{instructieformaat} te specificeren: een beschrijving hoe een sequentie bits een instructie bepaald. Men kan dit formaat natuurlijk vrij bepalen, maar meestal beoogt men een structurele opbouw: de instructie wordt onderverdeeld in \termen{velden}: groepen van bits waar een betekenis of een subtaak aan wordt toegekend. In de meeste instructieformaten komen volgende velden voor:
\begin{itemize}
 \item \termen{Instructietype}: een groep bits die de klasse van de instructie aangeeft (bijvoorbeeld een sprongbevel, een bewerking, een geprivilegieerde instructie,...)
 \item \termen{Opcode} ofwel \termen{operation code}: een groep bits die de bewerking voorstellen (bijvoorbeeld een optelling, vermenigvuldiging,...)
 \item Adres: een groep bits die de locatie van een operand of een resultaat specificeert. Een adres hoeft echter niet beperkt te zijn tot de locatie in een (extern) geheugen: ook registers en registerbanken kunnen soms worden geadresseerd.
 \item \termen{Adresseermode}: een adresseermode bepaald hoe het adres gespecificeerd in bits wordt omgezet in een fysisch adres. Zo kan de adresseermode bijvoorbeeld bepalen dat het adres een register uit de registerbank specificeert of dat de adressen indirect\footnote{Bij indirecte adressering leest men de waarde van het geheugen uit op de gegeven locatie. Die waarde bepaald dan de locatie van de effectieve waarde.} moeten worden berekend.
 \item Constante: bewerkingen zoals een optelling tellen soms een constante op bij een register. In dat geval moet de constante in de instructie worden ingebed.
\end{itemize}
Men dient op te merken dat een veld niet noodzakelijk een vaste lengte heeft of slechts \'e\'enmaal voorkomt. Stel bijvoorbeeld dat de adresseermode bepaald dat de gegevens uit een registerbank moeten uitgelezen worden, verwachten we dat het adres korter zal zijn dan wanneer we het adres uit een RAM-geheugen halen. Verder zal men bij sommige operaties twee of meer operanden moeten selecteren. In dat geval is het dus mogelijk dat het adresveld meerdere keren voorkomt. Sommige processoren kunnen voorzien ook een instructieformaat waarbij men twee of meer bewerkingen kan specificeren die dan parallel worden uitgevoerd. In dat geval komt de opcode dus twee of meer keer voor.
\subsection{Generische Instructiecyclus}
Een processor voert een instructie doorgaans uit in vijf stappen. Deze stappen noemt men de generische instructiecyclus. De stappen zijn:
\begin{enumerate}
 \item Lees de instructie in: het programmageheugen wordt uitgelezen en de instructie wordt in het \termen{instructieregister (IR)} opgeslagen. De programmateller wordt verhoogt.
 \item Bereken de adressen: Op basis van de adresseermodi en de adressen in de instructie worden de echte adressen bepaald. Een adres uit een registerbank zal er dus anders uitzien dan een adres uit het RAM-geheugen.
 \item Lees de operanden: de adressen van de operanden worden uitgelezen en weggeschreven in tijdelijke registers.
 \item Voer de bewerking uit: op basis van de data in de operand-registers en de opcode kan men de relevante bewerking op de relevante data uitvoeren. Het resultaat wordt in een tijdelijk register geplaatst.
 \item Schrijf het resultaat weg: het resultaat wordt weggeschreven in een registerbank of RAM-geheugen (indien dit relevant is voor de bewerking).
\end{enumerate}
Deze cyclus wordt eindeloos herhaalt en leent zich meestal erg goed tot pipelining: enkel wanneer de volgende instructie een operand moet inlezen die bepaald wordt door een instructie die kort ervoor is uitgevoerd moet de pipeline worden onderbroken. Men kan een sprongbevel uitvoeren door in de instructie de programmateller aan te passen.
\subsection{Uitvoeringssnelheid}
De uitvoeringssnelheid van een instructie hangt in grote mate af van twee factoren:
\begin{itemize}
 \item De snelheid van het datapad
 \item Het aantal toegangen tot extern geheugen.
\end{itemize}
We kunnen de snelheid van het datapad doorgaans opdrijven door meer hardware te voorzien die bijvoorbeeld bewerkingen in parallel uitvoeren. Het aantal toegangen tot extern geheugen kunnen we dan weer verlagen door kleine en simpele instructies te voorzien waardoor met elk een beperkt aantal operaties op het geheugen.
\paragraph{}
De grootte van een instructie is echter een trade-off. Wanneer we grote instructies voorzien met een groot aantal bits laten we de programmeur toe om een complexe taak in zo'n instructie te specificeren. Bijgevolg verwachten we dat een programma uit een klein aantal van dergelijke instructies zal bestaan. Omdat de instructies echter complex zijn, verwachten we een traag datapad en veel geheugentoegangen. Wanneer de processor enkel simpele instructies aanbied kan het datapad deze snel uitvoeren, maar een programma zal een groot aantal instructies bevatten. De complexiteit van een instructieset wordt dan ook soms uitgedrukt in het aantal adresvelden.
\subsection{Adresvelden}
In deze subsectie zullen we enkele instructiesets bespreken volgens het aantal adresvelden. Bij de verschillende instructiesets zullen we aantal geheugentoegangen berekenen die nodig zijn om de volgende $\brak{a+b}\times\brak{a-b}$ uit te rekenen. Deze operatie wordt doorgaans niet als \'e\'en instructie aangeboden (tenzij bij processoren die taken uitvoeren waarbij deze bewerking zeer regelmatig zou voorkomen). We zullen dan ook uitgaan van een algemene instructieset die de optelling (\termen{Add-instructie}), aftrekking (\termen{Sub-instructie}) en vermenigvuldiging (\termen{Mul-instructie}) voorziet.
\paragraph{}
Alvorens we de instructiesets met elkaar kunnen vergelijken, zullen we eerst enkele aannames moeten maken over hoe gegevens en instructies kunnen worden ingelezen. We zullen uitgaan van een woordlengte\footnote{De woordlengte is het aantal bits die in een geheugen onder \'e\'en adres worden opgeslagen.} $w$. We maken de assumptie dat een instructie zonder geheugenadressen in \'e\'en woord\footnote{Een woord is een sequentie van $w$ bits met $w$ de woordlengte.} kan worden opgeslagen. Het geheugen omvat $2^w$ adressen, bijgevolg telt het geheugen $w\cdot 2^w$ bits en is elk adres voor te stellen met een woord. Een instructie met $k$ geheugenadressen kan dus worden opgeslagen in $k+1$ woorden. We vergelijken de instructiesets op basis van geheugentoegangen. Dit zijn dus het aantal toegangen om de instructie uit te lezen samen met het uitlezen en wegschrijven van gegevens die in de instructie worden gespecificeerd.
\subsubsection{Instructies met 3 adresvelden}
Een instructieset met drie adresvelden bepaald meestal \'e\'en adres voor het resultaat en twee adressen voor de operanden. Bijvoorbeeld de \verb+Add a b c+ instructie berekend de optelling van de gegeven die op de geheugenplaatsen $b$ en $c$ staan en plaatst het resultaat dus in adres $a$. Om $\brak{a+b}\times\brak{a-b}$ dus uit te rekenen zullen we volgend programma uitvoeren:
\begin{verbatim}
Add c a b
Sub x a b
Mul c c x
\end{verbatim}
Per instructie voorzien we dus $4+3$ geheugentoegangen. $4$ instructietoegangen per instructie $2$ leesoperaties voor de operanden en $1$ schrijfoperatie. Omdat we $3$ instructies uitvoeren vereist het programma dus $21$ geheugentoegangen. We kunnen echter opmerken dat in de laatste instructies we tweemaal hetzelfde adres vermelden. Dit soort instructies vormen dan ook de argumentatie om soms instructies met twee adresvelden te gebruiken.
\subsubsection{Instructies met 2 adresvelden}
Instructiesets met twee adresvelden zijn vrij populair. \verb+80x86+ is een voorbeeld van zo'n instructieset. In zo'n instructieset vertegenwoordigen het eerste en tweede adresveld de adressen van de operanden en het eerste veld ook het adres van het resultaat. Het eerste adres wordt bijgevolg overschreven.
\paragraph{}
Een probleem bij dit mechanisme is dat we soms na de bewerking de operanden willen kunnen hergebruiken om andere operaties uit te voeren. Zo willen we na het berekenen van $a+b$ nog over $a$ en $b$ kunnen beschikken om $a-b$ uit te rekenen. We kunnen de waarde kopi\"eren om dit probleem te vermijden. We kunnen de waarde van $x$ kopi\"eren naar adres $y$ met behulp van twee instructies: \verb+Sub y y+ en \verb+Add y x+. De meeste processoren voorzien echter een kopieer instructie: de \termen{Mov-instructie}. Het voordeel van deze instructie is dat naast het ophalen van de instructie slechts twee geheugentoegangen vereist zijn.
\paragraph{}
We kunnen het algoritme dan ook als volgt implementeren:
\begin{verbatim}
Mov c a
Add c b
Mov x a
Sub x b
Mul c x
\end{verbatim}
De Mov-instructie vereist in totaal $5$ geheugentoegangen, de overige instructies vereisen $6$ geheugentoegangen. In totaal vereist het uitvoeren van het algoritme dus $28$ geheugentoegangen. We dienen echter wel op te merken dat de instructies sneller zullen worden uitgevoerd.
\subsubsection{Instructies met 1 adresvelden}
We kunnen de instructieset verder reduceren tot \'e\'en adresveld per instructie. Dit doen we met behulp van een \termen{accumulator (ACC)}. Een accumulator is een speciaal register die dienst doet als zowel de eerste operand en het register waar het resultaat in wordt geplaatst. Men kan deze instructieset dus vergelijken met de eerste instructieset, maar waarbij de eerste operator altijd een vast adres voorstelt. Het voordeel van een accumulator is de implementatie door middel van een register: de accumulator inlezen of resultaten wegschrijven vereist bijgevolg geen geheugentoegang.
\paragraph{}
Ook wanneer we een accumulator gebruiken zullen we soms tussenresultaten tijdelijk in een andere variabele willen opslaan om de waarde later in te lezen. We kunnen hier geen gebruik maken van de Mov-instructie omdat het resultaat altijd vast staat: de accumulator. Daarom worden twee nieuwe instructies ge\"introduceerd: de \termen{Load-instructie} leest het adres uit en plaatst de waarde in de accumulator, de \termen{Store-instructie} schrijft de waarde van de accumulator weg in het opgegeven adres. De Store-instructie is bijgevolg een instructie waar de accumulator geen dienst doet als de ontvanger van het resultaat.
\paragraph{}
We kunnen het algoritme realiseren met volgende code:
\begin{verbatim}
Load a
Add b
Store x
Load a
Sub b
Mul x
Store c
\end{verbatim}
Elke instructie vereist telkens $3$ geheugentoegangen: $2$ om de instructie uit te lezen en $1$ geheugentoegang om het adres uit te lezen of de resultaten weg te schrijven. Omdat het algoritme in $7$ instructies kan worden ge\"implementeerd, zijn er in totaal $21$ geheugentoegangen vereist.
\subsubsection{Instructies met 0 adresvelden}
\section{Processorontwerp}
\subsection{Complex Instruction Set Computer (CISC)}
\subsection{Reduced Instruction Set Computer (RISC)}