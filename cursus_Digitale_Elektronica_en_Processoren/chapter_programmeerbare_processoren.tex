\chapter{Programmeerbare Processoren}
\chapterquote{Mensen hebben met computers gemeen dat ze ook niets bereiken zonder goede programmeurs.}{Toon Verhoeven, Nederlands aforist (??-??)}
\begin{chapterintro}
In dit hoofdstuk bespreken we programmeerbare processoren. Deze processoren verschillen van de niet-programmeren processoren omdat een gebruiker een programma -- een reeks van instructies -- kan uitvoeren op de processor en bijgevolg in grote mate het algoritme die de processor uitvoert zelf kan bepalen. Centrale processoreenheden (CPU's) zijn hiervan slechts een subset van de programmeerbare processoren. We bespreken eerst de hoe een instructie eruitziet en hoe we een schakeling kunnen ontwerpen om deze instructies uit toe voeren. Cruciaal hierbij zijn de verschillende adresseermodi. Vervolgens beschouwen we de twee grote instructie-families: RISC en CISC. We zullen voor beide een instructieset ontwerpen en de verschillende aspecten die hierbij komen kijken bespreken.
\end{chapterintro}
\section{De Programmeerbare Processor}
We zullen in deze sectie het verschil bespreken tussen een niet-programmeerbare processor (zie \chpref{nonprogramming}) en een programmeerbare processor. Algemeen is deze grens eerder vaag. Ook bij een niet programmeerbare processor zullen de controller en het datapad meestal be\"invloed worden door signalen van buiten de schakeling. Sommige technici kunnen door deze invoer te manipuleren de processor een algoritme laten uitvoeren waarvoor de schakeling niet ontworpen was.
\paragraph{}
Een duidelijke grens kunnen we trekken bij de controller. Bij conventie stellen we dat een processor niet-programmeerbaar is wanneer de schakeling wordt aangestuurd met een vaste controller. In het geval we dus een ander algoritme willen uitvoeren zullen we een ander controller moeten implementeren om het uit te voeren. Bij een programmeerbare processor dient men de controller niet aan te passen. De controller beschikt immers over een geheugen waarin het programma geladen kan worden. Door het geheugen aan te passen zal de controller het datapad anders aansturen waardoor een ander algoritme kan worden uitgevoerd. We kunnen dus stellen dat de eindige toestandsautomaat die in de controller werd ge\"implementeerd vast staat, onafhankelijk van het ingeladen programma. Het geheugen waaruit zo'n controller leest noemen we het \termen{programmageheugen}. De gegevens die van de controller naar dit geheugen stuurt worden het \termen{adres}, de \termen{programmateller} of de \termen{program counter (PC)} genoemd. De data van het programmageheugen naar de controller noemen we de \termen{instructie}.
\paragraph{}
Merk op dat de definitie hierbij geen concrete uitspraak doet over hoe een programma of instructie er precies dient uit te zien. De definitie impliceert bijvoorbeeld niet dat de processor elk te beschrijven algoritme moet kunnen uitvoeren. Hierbij kunnen we bijvoorbeeld denken aan een ``Graphical Processing Unit (GPU)''. Een GPU is een programmeerbare processor die gespecialiseerd is in grafische taken. De instructieset is dan ook eerder beperkt tot grafische operaties. Hoewel men dergelijk processoren meestal niet kan programmeren om bijvoorbeeld Dijkstra's algoritme uit te voeren, is de processor wel programmeerbaar.
\paragraph{}
\figref{} toont hoe een programmeerbare processor er in grote lijnen uitziet. Merk op dat het enige verschil tussen deze figuur en \figrefpag{} de introductie van een programmageheugen is.
\section{Programma als een Reeks Instructies}

\section{Processorontwerp}
\subsection{Complex Instruction Set Computer (CISC)}
\subsection{Reduced Instruction Set Computer (RISC)}