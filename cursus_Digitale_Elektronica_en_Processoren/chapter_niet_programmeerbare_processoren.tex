\chapter{Niet-Programmeerbare Processoren}
\chapterquote{We accepteren nu het feit dat leren een levenslang proces is om op de hoogte te blijven van veranderingen. En de meest urgente taak is mensen te leren hoe te leren.}{Peter F. Drucker, Amerikaans management consultant en auteur (1909-)}
\begin{chapterintro}
In de twee vorige hoofdstukken hebben we componenten gebouwd met een beperkte functionaliteit. De combinatorische schakelingen laten ons toe om schakelingen te ontwerpen die een rekenkundige operatie uitvoeren, maar we hebben geen geheugen beschikbaar om tussenresultaten in op te slaan. Het hoofdstuk over sequenti\"ele schakelingen maakt het mogelijk om schakelingen te ontwerpen met een geheugen. De meeste problemen hebben echter zeer grote toestandsruimtes (een 32-bit getal heeft meer dan vier miljard toestanden). Daarom volstaan de methodes uit dit hoofdstuk niet om een component te ontwikkelen die iets functioneel doet. Daarvoor zullen we methodes op een hoger niveau introduceren, dat van een niet-programmeerbare processor. Een niet programmeerbare processor voert een algoritme uit die op voorhand gekend is. Hierdoor kunnen we optimaal gebruik maken van de hardware en zoveel mogelijk instructies tegelijk uitvoeren. Het nadeel is dat eenmaal de processor geproduceerd is, we geen andere problemen met het component kunnen uitvoeren.
\end{chapterintro}
\minitoc[n]
\section{De Niet-Programmeerbare Processor}
Alvorens we de bouw van zo'n processor verder uitwerken, dienen we eerst enkele concepten te formaliseren. Allereerst ontleden we in deze sectie uit welke delen zo'n processor is opgebouwd. Vervolgens zullen we in sectie \ref{s:descriptionFSMD} een methode ontwikkelen om een algoritme formeel weer te geven. Deze beschrijving zal toelaten het algoritme later om te zetten naar een processor. In sectie \ref{s:memoryFSMD} ten slotte zullen we extra geheugencomponenten introduceren die we nodig zullen hebben bij de bouw van een processor.
\subsection{Algemene Structuur}
Een \termen{Niet-programmeerbare processor}, ofwel \termen{Finite State Machine with Data path (FSMD)} bestaat grofweg uit twee delen:
\begin{itemize}
 \item Een \termen{datapad}: een component die bewerkingen (rekenkundig, aritmetisch,...) uitvoert en de resultaten opslaat in tijdelijk geheugen.
 \item Een \termen{controller}: een component die het datapad aanstuurt. Het zegt welke actie op welk moment moet ondernomen worden.
\end{itemize}
In dit hoofdstuk is de controller niet programmeerbaar. Dat wil zeggen dat de controller telkens hetzelfde programma uitvoert. Dit betekent echter niet dat er een vaste cyclus in de controller zit. De controller kan afhankelijk van de waarden die in de geheugens van het datapad zitten, of van ingangen van de processor beslissen om andere acties te ondernemen. Een controller is dus een sequenti\"ele schakeling ofwel finite state machine. De synthese van een finite state machine werd in het hoofdstuk \ref{ch:SeqComp} reeds besproken. Uiteraard zullen we de karakteristieken die eigen zijn aan controllers in dit hoofdstuk bespreken.
\paragraph{}
Het spreekt voor zich dat de controller en het datapad continu data met elkaar uitwisselen. Enerzijds geeft de controller instructies aan het datapad. De groep signalen waarmee een controller een datapad aanstuurt noemen we het ``\termen{instructiewoord}'' ofwel ``\termen{controle-signalen}''. Anderzijds zullen de instructies vaak afhangen van de toestand van variabelen opgeslagen in het datapad. De verzameling van signalen die het datapad over zijn variabelen doorstuurt naar de controller noemen we ``\termen{statussignalen}''.
\paragraph{}
Een processor voert operaties uit op data. Deze data moet op de een of andere manier ingelezen worden in de processor. De verzameling ingangen waarmee we data vanuit de omgeving in het datapad injecteren noemen we de ``\termen{data-ingangen}''. Verder zullen we vaak ook informatie aan de controller moeten meedelen: we denken bijvoorbeeld aan een signaal die actief wordt wanneer alle data ingelezen is, en het algoritme kan uitgevoerd worden. Deze signalen noemen we ``\termen{controle-ingangen}''. Daarnaast willen we ook de resultaten kunnen uitlezen. Hiervoor voorzien we een reeks signalen vanuit het datapad, deze signalen noemen we ``\termen{data-uitgangen}''. Tot slot zijn we soms ook ge\"interesseerd in de toestand van het algoritme. We zullen bijvoorbeeld enkel data uitlezen indien het algoritme afgelopen is. De controller kan informatie over het algoritme naar buiten brengen via ``\termen{controle-uitgangen}''. De verschillende informatiestromen tussen het datapad en de controller en de processor en zijn omgeving beschrijven we op figuur \ref{fig:processorInformationStreams}.
\begin{figure}[hbt]
\centering
\subfigure[Processor]{
\begin{tikzpicture}[scale=0.8]
\draw[gray,dashed,thick] (-2.5,-3) rectangle (2.5,3);
\draw (-2.5,0) node[rotate=-90,gray,anchor=south]{Processor};
\draw (-2.5,0) node[rotate=-90,gray,anchor=north]{Omgeving};
\node[rectangle,thick,draw=black,minimum width=2 cm,minimum height=0.75 cm] (D) at (0,2) {Datapad};
\node[rectangle,thick,draw=black,minimum width=2 cm,minimum height=0.75 cm] (C) at (0,-2) {Controller};
\draw[->,thick] (D.south -| 0.3333,0) to node[midway,sloped,above,scale=0.8]{status-signalen} (C.north -| 0.3333,0);
\draw[->,thick] (C.north -| -0.3333,0) to node[midway,sloped,above,scale=0.8]{instructiewoord} (D.south -| -0.3333,0);
\draw[<-,thick] (C.west) to node[below,midway,scale=0.8]{controle-ingangen} (-4.25,-2);
\draw[->,thick] (C.east) to node[below,midway,scale=0.8]{controle-uitgangen} (4.25,-2);
\draw[<-,thick] (D.west) to node[above,midway,scale=0.8]{data-ingangen} (-4.25,2);
\draw[->,thick] (D.east) to node[above,midway,scale=0.8]{data-uitgangen} (4.25,2);
\end{tikzpicture}
\label{fig:processorInformationStreams}}
\subfigure[Datapad]{
\begin{tikzpicture}[scale=0.8]
\draw[gray,dashed,thick] (-3.5,-3) rectangle (3.5,3);
\draw (-3.5,1.3) node[rotate=-90,gray,anchor=south]{Datapad};
\draw (-3.5,1.3) node[rotate=-90,gray,anchor=north]{Omgeving};
\node[rectangle,thick,draw=black,minimum width=2 cm] (T) at (0,1.25) {Tijdelijk geheugen};
\node[trapezium,thick,draw=black] (O) at (0,0) {Operatorverbindingen};
\node[rectangle,thick,draw=black,minimum width=2 cm] (F) at (0,-1.25) {Functionele eenheden};
\node[minimum width=2 cm] (RA) at (0,-2.5) {Resultaatverbindingen};
\node[minimum width=2 cm,white] (RB) at (0,2.5) {Resultaatverbindingen};
\draw[thick] (RA.north west) -- (O.bottom left corner |- RA.south) -- (RA.south east) -- ++(1,0) |- (RB.north west) -- (RB.south -| O.bottom left corner) -- (RB.south east) -- ++(0.5,0) |- (RA.north west);
\draw[thick,->] (RB) -- (T);
\draw[thick,->] (T) -- (O);
\draw[thick,->] (O) -- (F);
\draw[thick,->] (F) -- (RA);
\draw[<-,thick] (RA.west -| O.west) -- ++(-3,0);
\draw[<-,thick] (RB.west -| O.west) -- ++(-3,0);
\draw (-4,0) node[scale=0.8,anchor=south]{instructiewoord};
\draw (-4,-2.5) node[scale=0.8,anchor=south]{instructiewoord};
\draw (-4,2.5) node[scale=0.8,anchor=south]{externe-ingangen};
\draw (1.75,-3.5) node[scale=0.8,anchor=south]{externe-uitgangen};
\draw[<-,thick] (O.west) -- ++(-3,0);
\draw[->,thick] (RA) |- ++(3.5,-1);
\end{tikzpicture}
\label{fig:datapadInformationStreams}}
\caption{Opbouw van een processor en datapad.}
\end{figure}
\paragraph{}
Door de controle-ingangen wordt de definitie van ``niet-programmeerbaar'' natuurlijk vaag. We zouden immers het toestandswoord van de controller in grote mate laten afhangen van de invoer die de controle-ingangen. Hierdoor kunnen we de processor toch programmeren. Het onderscheid is dan ook eerder een common-sense.
\subsection{Het Datapad}
Zoals we reeds hebben vermeld, kunnen we een controller modelleren als een eindige toestandsautomaat ofwel finite state machine. Een datapad daarentegen bestaat uit verschillende componenten:
\begin{itemize}
 \item \termen{Functionele Eenheden} ofwel \termen{Functional Units (FU)}: dit zijn schakelingen die berekeningen en aritmetisch operaties uitvoeren. Dit zijn dus de componenten die we in hoofdstuk \ref{ch:combinatoric} hebben besproken: optellers, ALU, schuifoperator,... Uiteraard kunnen we ook zelf functionele eenheden bouwen op de manier die we gezien hebben.
 \item \termen{Tijdelijke geheugens}: dit zijn componenten die de waarden waarop we bewerkingen uitvoeren voor enkele klokcycli kunnen vasthouden. Dit zijn bijvoorbeeld de registerbanken en RAM die we in sectie \ref{s:memoryFSMD} zullen invoeren. Het zijn groepen van flipflops die ons toelaten om op een hoger niveau te redeneren.
 \item \termen{Verbindingen}: de tijdelijke geheugens en de functionele eenheden wisselen informatie uit. Daarom hebben we twee types verbindingen nodig:
 \begin{itemize}
  \item \termen{Operandverbindingen}: dit zijn verbindingen die de waardes van de tijdelijke geheugens overbrengen als operanden van de functionele eenheden. De waarde van een register kan op die manier bijvoorbeeld gebruikt worden bij een optelling.
  \item \termen{Resultaatverbindingen}: het is de bedoeling dat de resultaten vervolgens in een tijdelijk geheugen opgeslagen worden. Resultaatverbindingen transporteren de resultaten van de functionele eenheden terug naar de tijdelijke geheugens. Sommige uitvoer kan ook weggeschreven worden naar de data-uitgangen. Ook de invoer van de data-ingangen wordt door deze verbindingen verwerkt.
 \end{itemize}
 Het spreekt voor zich dat de verbindingen beslissen welke geheugens als operanden en resultaatgeheugens dienen. Daarom zullen we ze implementeren als bussen met multiplexers en 3-state buffers. Deze bussen zullen dan worden aangestuurd door de controller.
\end{itemize}
Dit concept beschrijven we op figuur \ref{fig:datapadInformationStreams}.
\paragraph{}
In het datapad doen we dan ook niets anders dan waardes uit het tijdelijke geheugen inlezen, er een operatie van een functionele eenheid op uitvoeren en vervolgens in een tijdelijk geheugen plaatsen. Dit proces noemen we ook wel de ``\termen{registertransfer}'' en formaliseren we als:
\begin{equation}
\mbox{register}_a\leftarrow\mbox{FU}_a\left(\mbox{register}_{a_1},\mbox{register}_{a_1},\mbox{register}_{a_2},\ldots,\mbox{register}_{a_n}\right)
\end{equation}
In het eerste hoofdstuk hebben we reeds vermeld dat we schakelingen bij het bouwen van een processor beschrijven op registertransfer-niveau. Dit betekent dat we bijvoorbeeld abstractie zullen maken van flipflops en zullen werken met registers. Ook zullen we details als het aantal bits die een opteller nodig heeft verwaarlozen. Deze nieuwe notatiestijl zullen we geleidelijk invoeren.
\section{Formeel Beschrijven van een Algoritme}
\label{s:descriptionFSMD}
Alvorens we een processor kunnen bouwen die een algoritme uitvoert, moeten we eerst een formeel algoritme kunnen opstellen. Dit algoritme vertrekt altijd vanuit een probleemstelling. Hoe we een probleemstelling omzetten naar een algoritme behoort niet tot de inhoud van deze cursus\footnote{Het omzetten van een probleem in een algoritme is geen exacte wetenschap. Het is een vaardigheid die wel geoefend kan worden. Hiervoor bestaan er andere cursussen.}. We zullen altijd stellen dat het algoritme vooraf gekend moet zijn.
\subsection{Leidend Voorbeeld: Deler}
Als leidend voorbeeld doorheen dit hoofdstuk zullen we een processor bouwen die natuurlijke getallen kan delen. Uiteraard zouden we hiervoor een combinatorische schakeling kunnen bouwen. We zullen echter een algoritme beschouwen om de berekening te maken. De processor heeft 2 4-bit ingangen die het deeltal en de deler inlezen. Verder bevat het ook een controle-ingang. Zolang we een laag signaal op de controle-ingang aanleggen betekent dit dat er geen correcte invoer op de data-ingangen staat. Pas wanneer we een hoog signaal aanleggen zal het algoritme dus een deling uitvoeren. Verder bevat de processor ook 2 4-bit uitgang om het quoti\"ent en de rest naar buiten te brengen, en een controle uitgang die hoog wordt op het moment dat het algoritme het quoti\"ent en de rest heeft berekend. Zolang de controle-uitgang dus laag is, is het algoritme nog bezig met de berekening. Verder zal de processor ook wachten totdat de controle-ingang eerst laag is geweest alvorens opnieuw te beginnen. We maken de assumptie dat de deler nooit gelijk is aan 0. Het algoritme die dan vervolgens het deeltal en de deler omzet in het quoti\"ent en rest staat op \algoref{alg:devisionFSMD}.
\begin{algorithm}[hbt]
\caption{Delen van twee $n$-bit getallen.}\label{alg:devisionFSMD}
\begin{algorithmic}[1]
\Function{Division}{$N,D$}
\State $Q\gets 0$
\State $R\gets 0$
\For{$I=n-1\mbox{ \textbf{to} }0$}
\State $R\gets R\shlcmd{}1$\Comment{Logische shift $R$ naar links over 1 positie}
\State $R\left[0\right]\gets N\left[n-1\right]$
\State $N\gets N\shlcmd{}1$\Comment{Logische shift $N$ naar links over 1 positie}
\State $Q\gets Q\shlcmd{}1$\Comment{Logische shift $Q$ naar links over 1 positie}
\If{$R\geq D$}
\State $R\gets R-D$
\State $Q\left[0\right]\gets 1$
\EndIf
\EndFor
\State \Return $\left(Q,R\right)$
\EndFunction
\end{algorithmic}
\end{algorithm}
We gaan niet in op de precieze werking van het algoritme. Indien we een index opvragen of zetten bij een variabele zoals $V\left[i\right]$ betekent dit dat we een operatie op de $i$-de bit uitvoeren. We tellen we van rechts naar links, $V[0]$ is dus de minst beduidende bit van $V$ die rechts staat in de encodering. Verder zullen we ook de subscript-notatie gebruiken wanneer we bits samen nemen. Zo betekent $v_2v_1w_2w_2v_2w_1$ dat we een getal samenstellen uit de eerste twee bits van $V$, gevolgd door de eerste en de derde bit van $W$, daarna volgen nog de derde bit van $V$ en de tweede bit van $W$. Dit algoritme is echter niet geschikt voor een processor. Een processor voert immers continu het programma uit. Bovendien wordt hier niet gewacht tot er invoer op de data-ingangen staat. Een laatste opmerking is dat we geen berekeningen op invoer kunnen uitvoeren. Anders zouden we immers de uitgangen van functionele eenheden met de ingangen van de processor verbinden. Daarom dienen we variabelen te introduceren die we $X$, $Y$ en $Z$. Daarom zullen we het algoritme herschrijven\footnote{Strikt genomen is dit geen algoritme meer, vermits het nooit eindigt en er geen echt resultaat is. Een betere bewoording is waarschijnlijk procedure.}. We beschouwen hierbij de controle-ingang $ci$ en de controle-uitgang $co$. De herschreven procedure staat in \algoref{alg:devisionFSMDRev}.
\begin{algorithm}[hbt]
\caption{Procedure voor het delen van twee $4$-bit getallen.}\label{alg:devisionFSMDRev}
\begin{algorithmic}[1]
\Procedure{Division}{}
\While{true}
\Repeat\label{algl:s1start}
\State $co\gets 0$
\State $X\gets N$
\State $Y\gets 0$
\State $Z\gets 0$
\Until{$ci$}\label{algl:s1stop}
\For{$I=3\mbox{ \textbf{to} }0$}\label{algl:s2start}
\State $Z\gets Z\shlcmd{}1$\Comment{Logische shift $Z$ naar links over 1 positie}
\State $Z\left[0\right]\gets X\left[3\right]$
\State $X\gets X\shlcmd{}1$\Comment{Logische shift $X$ naar links over 1 positie}
\State $Y\gets Y\shlcmd{}1$\Comment{Logische shift $Y$ naar links over 1 positie}
\If{$Z\geq D$}\label{algl:devisionFSMDComp}
\State $Z\gets Z-D$\label{algl:devisionFSMDSub}
\State $Y\left[0\right]\gets 1$
\EndIf
\EndFor\label{algl:s2stop}
\Repeat\label{algl:s3start}
\State $co\gets 1$
\State $Q\gets Y$
\State $R\gets Z$
\Until{$\neg ci$}\label{algl:s3stop}
\EndWhile
\EndProcedure
\end{algorithmic}
\end{algorithm}
\subsection{Toestandsbeschrijving}
Een eerste probleem dient zich aan hoe we de procedure omzetten in een reeks toestanden. De vraag is immers wat we in \'e\'en zo'n toestand zullen realiseren. Zo kunnen we \algoref{alg:devisionFSMDRev} uitvoeren en per instructie een nieuwe toestand bouwen. Als we echter het programma onder de loep nemen, zien we dat dit algoritme zich uitstekend leent om verschillende instructies samen uit te voeren. Allereerst voeren we in de \textbf{for}-lus hoofdzakelijke shift operaties uit. Deze shiftoperaties vinden plaats over een vast aantal posities. We dienen dus helemaal geen schuifoperator te implementeren, en kunnen eenvoudigweg schuiven met verbindingen. Vervolgens doen we ook aan bitmanipulaties. Omdat deze bitmanipulaties opnieuw op vaste plaatsen plaatsvinden kunnen we dit realiseren met behulp van verbindingen. De enige twee aspecten die enige logica vereisen is de test of $Z\geq D$ is (lijn \ref{algl:devisionFSMDComp}), en het eventueel aftrekken van $D$ uit $Z$ (lijn \ref{algl:devisionFSMDSub}). Daarnaast moeten we tijdens de uitvoer van de \textbf{for} lus ook controleren of $I\geq 0$. In dat geval dienen we immers nogmaals de for-lus uit te voeren. We kunnen dit echter controleren met een simpele OR-poort die alle bits van $I$ samenneemt. Indien minstens \'e\'en van de bits een 1 is, zal de OR-lus een 1 teruggeven, en dienen we dus nog een cyclus uit te voeren. Dit leidt ertoe dat we ons algoritme in drie toestanden opdelen:
\begin{enumerate}
 \item $S_0$: inlezen van invoer, initialiseren van variabelen en wachten totdat $ci$ hoog wordt (lijnen \ref{algl:s1start}-\ref{algl:s1stop}).
 \item $S_1$: uitvoeren van een cyclus van de \textbf{for} lus en $I$ met 1 verlagen (lijnen \ref{algl:s2start}-\ref{algl:s2stop}).
 \item $S_2$: resultaten op de uitgang plaatsen en wachten tot $ci$ laag wordt (lijnen \ref{algl:s3start}-\ref{algl:s3stop}).
\end{enumerate}
\subsection{Toestand-Actie Tabel}
Nu we de toestanden hebben vastgesteld kunnen we het algoritme verder formaliseren. Dit zouden we kunnen doen met een grafische voorstelling zoals we gedaan hebben met een eindige toestandsautomaat. Het probleem is dat een rij in het toestandsdiagram niet enkel de voorwaarden en eventuele uitgangen bevat, daarnaast dient het ook nog de acties die door het datapad moeten worden uitgevoerd weer te geven. Dit zou leiden tot een complex en chaotisch diagram. Daarom verkiezen we een tabel: de ``\termen{Toestand-Actie Tabel}''. De tabel bestaat grofweg uit drie gedeeltes:
\begin{itemize}
 \item de huidige toestand: de huidige toestand waarin de controller zich bevindt.
 \item Een toestandsgedeelte: die we kunnen vergelijken met de toestandstabel van een eindige toestandsautomaat. De tabel bevat volgende kolommen:
 \begin{itemize}
  \item condities (afhankelijk van controle- en status-signalen)
  \item de volgende toestand
  \item de uitvoer (van eventuele controle-uitgangen).
 \end{itemize}
 \item een controle-actie gedeelte. Dit gedeelte bevat twee kolommen:
 \begin{itemize}
  \item conditie: een set voorwaarden wanneer een bepaalde set acties (gespecificeerd in de volgende kolom) moet worden uitgevoerd.
  \item actie: afhankelijk van de conditie welke opdrachten uitgevoerd worden op de variabelen in een klokcyclus.
 \end{itemize}
\end{itemize}
Tabel \ref{tbl:stateActionTableRunningExample} toont de toestand-actie tabel van \algoref{alg:devisionFSMDRev}. Een belangrijke opmerking is dat het onderverdelen van toestanden in condities bij het toestandsgedeelte niet verder loopt bij het onderverdelen van diezelfde toestand in het controle-actie gedeelte. Dit betekent dus dat de conditie bij de volgende toestand niet de conditie bij de controle- en datapad-acties impliceert en omgekeerd. Concreet betekent dit dus dat indien $I>0$, dit niet betekent dat $z_2z_1z_0x_3<D$ of dat we de bijbehorende datapad-acties moeten uitvoeren. Het toestandsgedeelte en het controle-actie gedeelte zijn dus onafhankelijk en zijn enkel afhankelijk van de huidige toestand.
\begin{table}[hbt]
\centering
\begin{tabular}{c!{\vrule width 1pt}c|c|c!{\vrule width 1pt}c|c}
Huidige&\multicolumn{2}{c|}{Volgende toestand}&Uit-&\multicolumn{2}{c}{Controle- \& datapad-acties}\\
Toestand&Conditie&Toestand&gang&Conditie&Acties\\\noalign{\hrule height 1pt}
\multirow{4}{*}{$S_0$}&\multirow{2}{*}{$ci=0$}&\multirow{2}{*}{$S_0$}&\multirow{2}{*}{$co=0$}&&$X\gets N$\\
&&&&&$Y\gets 0$\\\cline{2-4}
&\multirow{2}{*}{$ci=1$}&\multirow{2}{*}{$S_1$}&\multirow{2}{*}{$co=0$}&&$Z\gets 0$\\
&&&&&$I\gets 3$\\\noalign{\hrule height 1pt}
\multirow{8}{*}{$S_1$}&\multirow{4}{*}{$I>0$}&\multirow{4}{*}{$S_1$}&\multirow{4}{*}{$co=0$}&\multirow{4}{*}{$z_2z_1z_0x_3<D$}&$Z\gets z_2z_1z_0x_3$\\
&&&&&$X\gets X\shlcmd 1$\\
&&&&&$Y\gets Y\shlcmd 1$\\
&&&&&$I\gets I-1$\\\cline{2-6}
&\multirow{4}{*}{$I=0$}&\multirow{4}{*}{$S_2$}&\multirow{4}{*}{$co=0$}&\multirow{4}{*}{$z_2z_1z_0x_3\geq D$}&$Z\gets z_2z_1z_0x_3-D$\\
&&&&&$X\gets X\shlcmd 1$\\
&&&&&$Y\gets y_2y_1y_01$\\
&&&&&$I\gets I-1$\\\noalign{\hrule height 1pt}
\multirow{6}{*}{$S_2$}&\multirow{3}{*}{$ci=0$}&\multirow{3}{*}{$S_0$}&$co=1$&&\\
&&&$Q=Y$&&\\
&&&$R=Z$&&\\\cline{2-4}
&\multirow{3}{*}{$ci=1$}&\multirow{3}{*}{$S_2$}&$co=1$&&\\
&&&$Q=Y$&&\\
&&&$R=Z$&&\\
\end{tabular}
\caption{Toestand-actie tabel van het leidend voorbeeld.}
\label{tbl:stateActionTableRunningExample}
\end{table}
\paragraph{Simulatie}Om ons meer vertrouwd te maken met het concept van een toestand-actie tabel zullen we een deling simuleren met behulp van de tabel. We zullen $N=12$ delen door $D=7$ op de processor en stap per stap kijken wat er verandert. Dit doen we met behulp van tabel \ref{tbl:stateActionTableRunningExampleSim}. Omdat we met bitoperaties werken zullen we alle variabelen in de tabel in binaire notatie zetten.
\begin{table}[hbt]
\centering
\begin{tabular}{c|c|c|c}
Toestand&Voldane Condities&Acties&Uitvoer\\\hline
\multirow{4}{*}{$S_0$}&\multirow{4}{*}{$ci=1$}&$X\gets N=1100$&\multirow{4}{*}{$co=0$}\\
&&$Y\gets0000$&\\
&&$Z\gets0000$&\\
&&$I\gets11$&\\\hline

\multirow{4}{*}{$S_1$}&\multirow{2}{*}{$I=11>00$}&$Z\gets z_2z_1z_0x_3=0001$&\multirow{4}{*}{$co=0$}\\
&&$X\gets X\shlcmd{} 1=1000$&\\
&\multirow{2}{*}{$z_2z_1z_0x_3=0001<D=0101$}&$Y\gets Y\shlcmd{} 1=0000$&\\
&&$I\gets I-1=10$&\\\hline

\multirow{4}{*}{$S_1$}&\multirow{2}{*}{$I=10>00$}&$Z\gets z_2z_1z_0x_3=0011$&\multirow{4}{*}{$co=0$}\\
&&$X\gets X\shlcmd{} 1=0000$&\\
&\multirow{2}{*}{$z_2z_1z_0x_3=0011<D=0101$}&$Y\gets Y\shlcmd{} 1=0000$&\\
&&$I\gets I-1=01$&\\\hline

\multirow{4}{*}{$S_1$}&\multirow{2}{*}{$I=01>00$}&$Z\gets z_2z_1z_0x_3-D=0001$&\multirow{4}{*}{$co=0$}\\
&&$X\gets X\shlcmd{} 1=0000$&\\
&\multirow{2}{*}{$z_2z_1z_0x_3=0110\geq D=0101$}&$Y\gets y_2y_1y_01=0001$&\\
&&$I\gets I-1=00$&\\\hline

\multirow{4}{*}{$S_1$}&\multirow{2}{*}{$I=00$}&$Z\gets z_2z_1z_0x_3=0010$&\multirow{4}{*}{$co=0$}\\
&&$X\gets X\shlcmd{} 1=0000$&\\
&\multirow{2}{*}{$z_2z_1z_0x_3=0010<D=0101$}&$Y\gets Y\shlcmd{} 1=0010$&\\
&&$I\gets I-1=11$&\\\hline

\multirow{3}{*}{$S_2$}&\multirow{3}{*}{$ci=0$}&&$co=1$\\
&&&$Q=Y=0010$\\
&&&$R=Z=0010$\\
\end{tabular}
\caption{Simulatie van het algoritme met behulp van de toestand-actie tabel (tabel \ref{tbl:stateActionTableRunningExample}).}
\label{tbl:stateActionTableRunningExampleSim}
\end{table}
We stellen dat vanaf dat we de simulatie beginnen, reeds de data reeds op de ingangen van de processor aangelegd staat. Bijgevolg is $ci=1$, $N=1100$ en $D=0101$. We maken verder ook een assumptie dat $X$, $Y$ en $Z$ 4-bit geheugens zijn, dit is redelijk vermits we uitsluitend bits in dit bereik gebruiken, en we geen schuifoperaties naar rechts uitvoeren waardoor hogere bits in het bereik zouden komen te liggen. $I$ is een 2-bit geheugen vermits het uitsluitend waardes tussen 0 en 3 moet aannemen. Initieel vertrekt de processor vanuit toestand $S_0$ we zien op die toestand-actie tabel dat in toestand $S_0$ de ingangen in de geheugens worden ingelezen. Vermits er data op de ingangen staat, krijgt $X$ de waarde van de teller $N=1100$. De overige variabelen worden ge\"initialiseerd zoals beschreven staat in de toestand-actie tabel. Omdat $ci=1$ kunnen we afleiden dat de volgende toestand $S_1$ is. Verder specificeert de tabel ook dat we een laag signaal op de controle-uitgang moeten aanleggen (momenteel staat er immers geen uitkomst op de uitgangen). In de volgende stap bevinden we ons in toestand $S_1$. We evalueren eerst de verschillende condities ??.
\subsection{ASM-Schema}
Zoals reeds gezegd is de visualisatie van een eindige toestandsautomaat niet toereikend om een algoritme weer te geven. Een grafisch voorstelling die we wel kunnen gebruiken is een ``\termen{Algorithmic-State-Machine Chart}'' ofwel ``\termen{ASM-schema}''.
\subsubsection{ASM-Elementen}
Een ASM-schema lijkt op een flow-chart en bestaat drie verschillende soorten ``\termen{ASM-elementen}'':
\begin{itemize}
 \item \termen{Toestandskader} ofwel \termen{state box}: dit is een set niet-conditionele toekenning. We stellen een toestandskader voor door middel van een rechthoek waarin we de toekenningen schrijven. De toekenningen in \'e\'en toestandskader worden parallel uitgevoerd. Daarnaast bevat een toestandskader ook de status- en data-uitgangen van de processor. Men maakt een onderscheid doordat toekenningen met een pijl ($\gets$) weergegeven worden en uitgangen met een gelijkheidsteken ($=$). Figuur \ref{fig:asmElementState} toont een voorbeeld van een toestandskader.
 \item \termen{Beslissingskader} ofwel \termen{decision box}: dit is de voorstelling van een bepaalde conditie. Een conditie wordt voorgesteld met behulp van een ruit, waarin de conditie wordt geschreven. Vanuit een beslissingskader vertrekken er twee pijlen: voor het geval waarin de voorwaarde waar of vals is. We noteren de pijlen dan ook respectievelijk met ``[True]'' en ``[False]'', soms wordt ook 1 en 0 gebruikt. Figuur \ref{fig:asmElementDecision} toont een voorbeeld van een beslissingskader.
 \item \termen{Conditioneel kader} ofwel \termen{conditional box}: Dit is een toestandskader die enkel onder voorwaarden gespecificeerd door een beslissingskader worden uitgevoerd. Ook deze toekenningen worden in parallel uitgevoerd. Verder bevat een conditioneel kader ook de conditionele uitvoer op de processoruitgangen. We noteren toekenningen en uitgangen op dezelfde manier als bij toestandskaders. Men stelt een conditioneel kader voor als een rechthoek met afgeronde hoeken. Figuur \ref{fig:asmElementConditional} toont een voorbeeld van een conditioneel kader.
\end{itemize}
\begin{figure}[hbt]
\centering
\subfigure[Toestandskader]{
\begin{tikzpicture}
%\node[asmS] (S) at (0,0) {$\begin{array}{c}\mbox{niet conditioneel commando 1}\\\mbox{niet conditioneel commando 2}\\\cdots\\\mbox{niet conditioneel commando $n$}\end{array}$};
\node[asmS] (S) at (0,0) {$\begin{array}{c}\mbox{variabele$_1\gets$ expressie$_1$}\\\cdots\\\mbox{variabele$_m\gets$ expressie$_m$}\\\mbox{uitgang$_1=$ expressie$_{m+1}$}\\\cdots\\\mbox{uitgang$_n=$ expressie$_{m+n}$}\end{array}$};
\draw[<-] (S) -- ++(0,1.5) node[anchor=south]{in};
\draw[->] (S) -- ++(0,-1.5) node[anchor=north]{uit};
\end{tikzpicture}
\label{fig:asmElementState}
}
\subfigure[Beslissingskader]{
\begin{tikzpicture}
\node[asmD] (D) at (0,0) {test};
\draw[<-] (D) -- ++(0,1.5) node[anchor=south]{in};
\draw[->] (D) -| ++(-1.75,-1.5) node[anchor=north]{uit 1};
\draw[->] (D) -| ++(1.75,-1.5) node[anchor=north]{uit 2};
\draw (-1.75,0) node[anchor=south west,scale=0.75]{[True]};
\draw (1.75,0) node[anchor=south east,scale=0.75]{[False]};
\end{tikzpicture}
\label{fig:asmElementDecision}
}
\subfigure[Conditioneel kader]{
\begin{tikzpicture}
%\node[asmC] (C) at (0,0) {$\begin{array}{c}\mbox{conditioneel commando 1}\\\mbox{conditioneel commando 2}\\\cdots\\\mbox{conditioneel commando $n$}\end{array}$};
\node[asmC] (C) at (0,0) {$\begin{array}{c}\mbox{variabele$_1\gets$ expressie$_1$}\\\cdots\\\mbox{variabele$_m\gets$ expressie$_m$}\\\mbox{uitgang$_1=$ expressie$_{m+1}$}\\\cdots\\\mbox{uitgang$_n=$ expressie$_{m+n}$}\end{array}$};
\draw[<-] (C) -- ++(0,1.5) node[anchor=south]{in};
\draw[->] (C) -- ++(0,-1.5) node[anchor=north]{uit};
\end{tikzpicture}
\label{fig:asmElementConditional}
}
\caption{Voorstelling van de verschillende ASM-elementen}
\label{fig:asmElementsEnum}
\end{figure}
\subsubsection{Het ASM-Blok}
Deze ASM-elementen worden gegroepeerd in een ``\termen{ASM-blok}''. Alle ASM-elementen die in eenzelfde ASM-blok zitten, worden dan in \'e\'en klokcyclus uitgevoerd. Hierdoor voorzien we per toestand in de Toestand-Actie tabel een ASM-blok. Het blok zelf moet dan specificeren wat er in de toestand gebeurt. We zullen dit component voorstellen met behulp van een vierkant met streepjeslijnen. Vermits alle acties in \'e\'en klokflank uitgevoerd worden, bevat elk ASM-blok exact \'e\'en toestandskader. Dit toestandskader bevat dan alle toekenningen en uitgangen die onafhankelijk van condities in die toestand worden uitgevoerd. Indien er geen onafhankelijke operaties zijn, is het vierkant leeg. Indien er naast onafhankelijke acties ook onafhankelijk acties gebeuren (zowel in het toestand- als het actie-gedeelte), zullen we vervolgens enkele beslissingskaders plaatsen. We voeren testen uit op variabelen in het datapad door middel van status-signalen en eventuele signalen aan de controle-ingangen. Vermits we al deze testen reeds in de toestand-actie-tabel hebben gedefinieerd kunnen we eenvoudig de toestand-actie-tabel omvormen tot een ASM-schema. Zo staat op figuur \ref{fig:aSMSchemaRunningExample} het ASM-schema voor het leidend voorbeeld.
\begin{figure}[hbt]
\centering
\begin{tikzpicture}
\def\ds{6};
\def\di{1.75};
\def\dy{-2};
\def\offset{1};
\node[asmS] (S1S) at (0,0) {$\begin{array}{c}X\gets N\\Y\gets 0\\Z\gets 0\\I\gets 3\\co=0\end{array}$};
\node[asmD] (S1D) at (0,\dy) {$ci=0$};
\draw[->] (S1S) -- (S1D);
\draw[->] (S1D) -| (-\di,0) -- (S1S);
\setTrueFalseLabels{S1D};

\node[asmS] (S2S) at (\ds,0) {$\begin{array}{c}X\gets X\shlcmd 1\\I\gets I-1\\co=0\end{array}$};
\node[asmD] (S2D1) at (\ds,\dy) {$z_2z_1z_0x_3<D$};
\draw[->] (S2S) -- (S2D1);
\node[asmC] (S2C1) at (\ds-\di,2*\dy) {$\begin{array}{c}Z\gets z_2z_1z_0x_3\\Y\gets Y\shlcmd{} 1\end{array}$};
\draw[->] (S2D1) -| (S2C1);
\node[asmC] (S2C2) at (\ds+\di,2*\dy) {$\begin{array}{c}Z\gets z_2z_1z_0x_3-D\\Y\gets y_2y_1y_01\end{array}$};
\draw[->] (S2D1) -| (S2C2);
\draw (S2C1) |- (\ds,2.5*\dy) -| (S2C2);
\node[asmD] (S2D2) at (\ds,3*\dy) {$I>0$};
\draw[->] (\ds,2.5*\dy) -- (S2D2);
\draw[->] (S1D) -| (\di,\offset) -| (S2S);
\draw[->] (S2D2) -| (\ds-2*\di,0) -- (S2S);
\setTrueFalseLabels{S2D1};
\setTrueFalseLabels{S2D2};

\node[asmS] (S3S) at (2*\ds,0) {$\begin{array}{c}co=1\end{array}$};
\node[asmD] (S3D) at (2*\ds,\dy) {$ci=1$};
\node[asmN] (N1) at (2*\ds,2*\dy) {$\begin{array}{c}Q=Y\\R=Z\end{array}$};
\draw[->] (S2D2) -| (\ds+2*\di,\offset) -| (S3S);
\draw[->] (S3S) -- (S3D);
\draw[->] (S3D) -| (2*\ds-\di,0) -- (S3S);
\draw[->] (S3D) -| (\di+2*\ds,1.5) -| (S1S);
\setTrueFalseLabels{S3D};
\begin{pgfonlayer}{background}
\node[asmB, fit=(S1S) (S1D)] (S1) {};
\node[asmB, fit=(S2S) (S2D1) (S2D2) (S2C1) (S2C2)] (S2) {};
\node[asmB, fit=(S3S) (S3D)] (S3) {};
\end{pgfonlayer}
\draw (S1.south west) node[anchor=south west]{$S_1$};
\draw (S2.south west) node[anchor=south west]{$S_2$};
\draw (S3.south west) node[anchor=south west]{$S_3$};
\end{tikzpicture}
\caption{ASM-schema van het leidend voorbeeld.}
\label{fig:aSMSchemaRunningExample}
\end{figure}
\subsubsection{Traditionele Valkuilen}
Traditioneel maakt men een aantal fouten tegen ASM-schemas. In deze subsubsectie zullen we een overzicht geven van de meest gemaakte fouten.
\begin{figure}[hbt]
\centering
\subfigure[Meerdere volgende toestanden]{
\begin{tikzpicture}
\node[asmS] (A0) at (0,0) {$A_0$};
\node[asmD] (T0) at (-1.75,-1.25) {$t_1$};
\node[asmD] (T1) at (1.75,-1.25) {$t_2$};
\node[asmS] (A1) at (-3,-2.375) {$A_1$};
\node[asmS] (A2) at (0,-2.375) {$A_2$};
\node[asmS] (A3) at (3,-2.375) {$A_3$};
\setTrueFalseLabels{T0};
\setTrueFalseLabels{T1};
\draw[->] (A0) -- (0,-0.5) -| (T0);
\draw[->] (0,-0.5) -| (T1);
\draw[->] (T0) -| (A1);
\draw[->] (T1) -| (A3);
\draw[->] (T0) -| (A2);
\draw[<-] (A0) -- ++(0,0.75);
\draw (T1) -| (0,-1.25);
\pdot{0,-0.5};
\pdot{0,-1.25};
\begin{pgfonlayer}{background}
\node[asmB, fit=(A0) (T0) (T1)] (S1) {};
\node[asmB, fit=(A1)] (S2) {};
\node[asmB, fit=(A2)] (S3) {};
\node[asmB, fit=(A3)] (S4) {};
\end{pgfonlayer}
\draw (S1.south west) node[anchor=south west]{$S_1$};
\draw (S2.south west) node[anchor=south west]{$S_2$};
\draw (S3.south west) node[anchor=south west]{$S_3$};
\draw (S4.south west) node[anchor=south west]{$S_4$};
\end{tikzpicture}
\label{fig:badASMMultipleFlows}
}
\subfigure[Geen volgende toestanden]{
\begin{tikzpicture}
\node[asmS] (A0) at (0,0) {$A_0$};
\node[asmD] (T0) at (0,-1.25) {$t_1$};
\node[asmS] (A1) at (1.25,-2.375) {$A_1$};
\setTrueFalseLabels{T0};
\draw[->] (A0) -- (T0);
\draw[->] (T0) -| (A1);
\draw[<-] (A0) -- ++(0,0.75);
\draw (T0) -| (-1.25,-0.5) -- (0,-0.5);
\pdot{0,-0.5};
\begin{pgfonlayer}{background}
\node[asmB, fit=(A0) (T0)] (S1) {};
\node[asmB, fit=(A1)] (S2) {};
\end{pgfonlayer}
\draw (S1.south west) node[anchor=south west]{$S_1$};
\draw (S2.south west) node[anchor=south west]{$S_2$};
\end{tikzpicture}
\label{fig:badASMNoFlows}
}
\subfigure[Meerdere toekenningen]{
\begin{tikzpicture}
\node[asmS] (A0) at (0,0) {$X\gets 0$};
\node[asmD] (T0) at (0,-0.75) {$t_1$};
\node[asmC] (A1) at (1.25,-1.5) {$X\gets 1$};
\node[asmS] (A2) at (0,-2.5) {$A_0$};
\setTrueFalseLabels{T0};
\draw[->] (A0) -- (T0);
\draw[->] (T0) -| (A1);
\draw[<-] (A0) -- ++(0,0.75);
\draw[->] (T0) -| (-1.25,-2) -| (A2);
\draw (A1) |- (0,-2);
\pdot{0,-2};
\begin{pgfonlayer}{background}
\node[asmB, fit=(A0) (T0) (A1)] (S1) {};
\node[asmB, fit=(A2)] (S2) {};
\end{pgfonlayer}
\draw (S1.south west) node[anchor=south west]{$S_1$};
\draw (S2.south west) node[anchor=south west]{$S_2$};
\end{tikzpicture}
\label{fig:badASMMultipleAssignments}
}
\subfigure[Testen op nieuwe waarden]{
\begin{tikzpicture}
\node[asmS] (A0) at (0,0.25) {$a\gets a-1$};
\node[asmD] (T0) at (0,-0.75) {$a>3$};
\node[asmC] (A1) at (-1.25,-1.5) {$b\gets 2$};
\node[asmS] (A2) at (0,-2.5) {$A_0$};
\setTrueFalseLabels{T0};
\draw[->] (A0) -- (T0);
\draw[->] (T0) -| (A1);
\draw[<-] (A0) -- ++(0,0.75);
\draw[->] (T0) -| (1.25,-2) -| (A2);
\draw (A1) |- (0,-2);
\pdot{0,-2};
\begin{pgfonlayer}{background}
\node[asmB, fit=(A0) (T0) (A1)] (S1) {};
\node[asmB, fit=(A2)] (S2) {};
\end{pgfonlayer}
\draw (S1.south west) node[anchor=south west]{$S_1$};
\draw (S2.south west) node[anchor=south west]{$S_2$};
\end{tikzpicture}
\label{fig:badASMTests}
}
\subfigure[Gebruik nieuwe waarde]{
\begin{tikzpicture}
\node[asmS] (A00) at (0,0) {$y\gets x+1$};
\node[asmS] (A01) at (0,-1) {$z\gets y+2$};
\draw[->] (0,0.75) -- (A00);
\draw[->] (A00) -- (A01);
\draw[->] (A01) -- (0,-1.75);
\node (A) at (1.5,-0.5) {$\neq$};
\node[asmS] (A1) at (3,-0.5) {$\begin{array}{c}y\gets x+1\\z\gets y+2\end{array}$};
\draw[->] (3,0.75) -- (A1);
\draw[->] (A1) -- (3,-1.75);
\end{tikzpicture}
\label{fig:badASMUsage}
}
\subfigure[Conditioneel na toestandskader]{
\begin{tikzpicture}
\node[asmS,minimum width=3cm] (A00) at (0,0) {$A_0$};
\node[asmC,minimum width=3cm] (A01) at (0,-1) {$A_1$};
\draw[->] (0,0.75) -- (A00);
\draw[->] (A00) -- (A01);
\draw[->] (A01) -- (0,-1.75);
\end{tikzpicture}
\label{fig:badCAfterS}
}
\subfigure[Toewijzen uitgang]{
\begin{tikzpicture}
\node[asmS] (A1) at (3,-0.5) {$\mbox{uitgang}\gets\mbox{expressie}$};
\draw[->] (3,0.75) -- (A1);
\draw[->] (A1) -- (3,-1.75);
\end{tikzpicture}
}
\caption{Traditionele valkuilen bij het maken van ASM-schema's.}
\label{fig:badASM}
\end{figure}
\paragraph{Meerdere volgende toestanden}Men kan in een ASM-schema een flow chart tekenen waarbij onder bepaalde condities, men twee verschillende pijlen kan volgen. Een voorbeeld van zo'n flow chart staat op figuur \ref{fig:badASMMultipleFlows}. Indien bijvoorbeeld test $t_1$ slaagt en $t2$ faalt, dienen we de stromen naar $A_1$ \'en $A_3$ te volgen. Dit is niet zo problematisch wanneer dit in hetzelfde ASM-blok gebeurd (we kunnen argumenteren dat we dan alle toewijzingen uit $A_1$ en $A_3$ uitvoeren). Indien we echter later naar verschillende toestanden gaan krijgen we problemen. We kunnen dit probleem makkelijk verhelpen door geen vertakkingen met pijlen toe te staan. Enkel uit het beslissingskader vertrekken twee pijlen. Uit een toestands- en conditioneel kader vertrekt altijd slechts \'e\'en pijl. Het samenbrengen van pijlen is wel toegelaten.
\paragraph{Geen volgende toestand}Ook het omgekeerde kan voorkomen: een ASM-blok waarbij we geen volgende toestand bekomen bij een bepaalde situatie. Figuur \ref{fig:badASMNoFlows} toont een minimaal voorbeeld: indien aan $t_1$ wordt voldaan zullen we nooit naar een volgende toestand overgaan. Dit komt omdat de pijl nooit een toestandskader bereikt (en we dus in een volgende toestand komen. Ook dit probleem kunnen we eenvoudig voorkomen: in elk ASM-blok gaan alle mogelijke lussen doorheen het toestandskader.
\paragraph{Verschillende toekenningen aan dezelfde variabele} Tijdens \'e\'en klokflank kan een variabele slechts \'e\'enmaal van waarde veranderen. We kunnen in een ASM-blok echter meerdere kaders plaatsen die elk een waarde aan dezelfde variabele toekennen. Figuur \ref{fig:badASMMultipleAssignments} toont zo'n situatie: indien $t_1$ niet waar is, kennen we zowel $0$ als $1$ toe aan $X$. Men kan argumenteren dat $X$ dan de waarde $1$ krijgt, omdat dit de laatste toekenning is aan $X$ in het diagram. De componenten die in een ASM-blok staan kunnen dus vrij verandert worden in volgorde. Bovendien zullen we in sectie \ref{s:syntheseFSMD} een mechanisme ontwikkelen om deze ASM-schema's om te zetten in hardware. Incorrecte ASM-schema's zullen leiden tot implementatiefouten. We kunnen dit voorkomen door bij elk ASM-blok alle mogelijke paden te analyseren en te controleren dat geen variabele twee toewijzingen krijgt.
\paragraph{Testen van nieuwe waarde} Omdat alles in een ASM-blok tegelijk gebeurt zijn de waardes van variabelen ook nog niet aangepast wanneer we een toestandsblok verlaten. Zolang we ons echter nog in hetzelfde ASM-blok bevinden, zijn die aanpassingen nog niet doorgevoerd. Stel dat we bijvoorbeeld volgende \texttt{C} programma beschouwen:
\begin{verbatim}
a--;
if(a > 3) {
  b = 2;
}
\end{verbatim}
Dan kunnen we dit vertalen naar \'e\'en toestand in het ASM-schema. Figuur \ref{fig:badASMTests} is echter niet de juiste vertaling. Stel immers dat $a=4$ dan zal in het \texttt{C}-programma de \texttt{if}-lus niet uitgevoerd worden, $a$ heeft immers voor het \texttt{if}-statement de waarde $3$. In het ASM-schema krijgt $a$ ook de waarde $3$, maar alleen nadat we het ASM-blok verlaten hebben. Bijgevolg zal bij de voorwaarde $a$ nog steeds de waarde $4$ hebben. En zal de \texttt{if}-lus uitgevoerd worden. Een oplossing is om in dit geval gewoon te testen op $a-1>3$ of dus $a>4$.
\paragraph{Gebruiken van een nieuwe waarde} Een verwante traditionele fout is het gebruiken van de nieuwe waarde in de volgende berekening. Een voorbeeld van dit concept staat op figuur \ref{fig:badASMUsage}. Hier zien we twee ASM-schema's die niet equivalent zijn. Indien bijvoorbeeld $x=2$ en $y=1$ zal in de eerste flow $z=5$. In het tweede geval is $z=3$. Indien beide kaders in een verschillend ASM-blok of -element staan, is dit uiteraard toegelaten. Indien de toekenningen in hetzelfde ASM-element of ASM-blok staan, worden de opdrachten parallel uitgevoerd, en zullen we dus de oude waarde gebruiken. Men kan dit fenomeen testen door de volgorde van toekenningen in een ASM-element te wijzigen of de beslissingskaders en hun bijbehorende conditionele kaders anders te schikken. Nadat deze volgorde dan wijzigt, zou het programma nog steeds op dezelfde manier moeten werken.
\paragraph{Aanduiden van controller-uitgangen}We zijn reeds kort ingegaan op de notatie van uitgangen in de toestand- en conditionele kaders. We noteren de waarde van een uitgang met behulp van een gelijkheidsteken ($=$). Indien we de uitgang niet vermelden, staat er een 0 op die uitgang (in het geval van meerdere bits, zijn alle bits dus 0). Soms komt het ook voor dat een uitgang in elke toestand een combinatorische schakeling van enkele variabelen is. In dat geval moeten we deze uitgang niet in elk toestandskader vermelden, maar volstaat het om een nota te maken, zoals we ook op figuur \ref{fig:aSMSchemaRunningExample}. Deze nota is geen onderdeel van het ASM-schema, en wordt makkelijk vergeten.
\paragraph{Conditioneel kader na toestandskader}Een laatste fout die regelmatig terugkomt is het plaatsen van een conditioneel kader na een toestandskader zoals op figuur \ref{fig:badCAfterS}. Vermits er geen beslissingskader aan vooraf gaat, is dit conditioneel kader helemaal niet gebonden aan een voorwaarde. Dit probleem lossen we op door het conditioneel kader om te vormen tot een toestandskader. Indien beide kaders bovendien in eenzelfde ASM-blok staan, kunnen we de inhoud van beide kaders samennemen in \'e\'en toestandskader.
\subsubsection{Inputgebaseerde en Toestandsgebaseerde ASM-schema's}
We hebben het reeds kort gehad over het toekennen van toestanden aan delen van een programma besproken. Een belangrijk aspect daarbij is dat we ASM-schema's kunnen onderverdelen in twee categorie\"en:
\begin{itemize}
 \item \termen{Inputgebaseerd ASM-schema}: In dit schema kunnen we de waarde van testen (status-signale) en controle-ingangen onmiddellijk gebruiken. Een inputgebaseerd ASM-schema van het leidend voorbeeld stond op figuur \ref{fig:aSMSchemaRunningExample}.
 \item \termen{Toestandsgebaseerd ASM-schema}: Hierbij kunnen we de waardes van testen (status-signalen) en controle-ingangen pas in de volgende klokflank gebruiken. Het betekent dus dat elke voorwaardelijke uitvoering van een opdracht gepaard gaat met de overgang naar een nieuwe toestand. Bijgevolg bevat dit diagram ook geen conditionele kaders.
\end{itemize}
Inputgebaseerde ASM-schema's kunnen meer opdrachten uitvoeren in een klokflank, omdat we niet moeten wachten op het kloksignaal om conditionele operaties uit te voeren. Anderzijds zal dit ASM-schema tot een langere klokcyclus leiden. Dit komt omdat de testen eerst moeten berekend worden alvorens we sommige opdrachten kunnen uitvoeren. Een nadeel van toestandsgebaseerde ASM-schema's is dat we meer toestanden nodig hebben, wat zal leiden tot een groter geheugen en mogelijk ook logica.
\paragraph{}
De termen inputgebaseerd en toestandsgebaseerd komen van de controller. We hebben reeds besproken dat een controller een eindige toestandsautomaat is. Ook bij deze eindige toestandsautomaten hebben we deze indeling gemaakt. Een toestandsgebaseerd ASM-schema zal aanleiding geven tot een toestandsgebaseerde controller en vice versa. Bij wijze van voorbeeld zullen we het leidend voorbeeld ook met een toestandsgebaseerd ASM-schema visualiseren op figuur \ref{fig:aSMSchemaRunningExampleState}.
\begin{figure}[hbt]
\centering
\begin{tikzpicture}
\def\ds{6};
\def\di{1.75};
\def\dy{-2};
\def\offset{1};
\node[asmS] (S1S) at (0,0) {$\begin{array}{c}X\gets N\\Y\gets 0\\Z\gets 0\\I\gets 3\\co=0\end{array}$};
\node[asmD] (S1D) at (0,\dy) {$ci=0$};
\draw[->] (S1S) -- (S1D);
\draw[->] (S1D) -| (-\di,0) -- (S1S);
\setTrueFalseLabels{S1D};

\node[asmS] (S2S) at (\ds,0) {$\begin{array}{c}X\gets X\shlcmd 1\\co=0\end{array}$};
\node[asmD] (S2D1) at (\ds,\dy) {$z_2z_1z_0x_3<D$};
\draw[->] (S2S) -- (S2D1);
\node[asmS] (S4S) at (\ds-\di,2*\dy) {$\begin{array}{c}Z\gets z_2z_1z_0x_3\\I\gets I-1\\Y\gets Y\shlcmd{} 1\end{array}$};
\draw[->] (S2D1) -| (S4S);
\node[asmS] (S5S) at (\ds+\di,2*\dy) {$\begin{array}{c}Z\gets z_2z_1z_0x_3-D\\I\gets I-1\\Y\gets y_2y_1y_01\end{array}$};
\draw[->] (S2D1) -| (S5S);
\node[asmD] (S4D) at (\ds-\di,3*\dy) {$I>0$};
\draw[->] (S4S) -| (S4D);
\node[asmD] (S5D) at (\ds+\di,3*\dy) {$I>0$};
\draw[->] (S5S) -| (S5D);
\draw[->] (S1D) -| (\di,\offset) -| (S2S);
\draw[->] (S4D) -| (\ds-2*\di,0) -- (S2S);
\setTrueFalseLabels{S2D1};
\setTrueFalseLabels{S4D};
\setTrueFalseLabels{S5D};

\node[asmS] (S3S) at (2*\ds,0) {$\begin{array}{c}co=1\end{array}$};
\node[asmD] (S3D) at (2*\ds,\dy) {$ci=1$};
\node[asmN] (N1) at (2*\ds,2*\dy) {$\begin{array}{c}Q=Y\\R=Z\end{array}$};
\draw[->] (S4D) -| (\ds-0.375*\di,3.75*\dy) -| (\ds+2*\di,\offset) -| (S3S);
\draw (S5D) -| (\ds+0.375*\di,3.5*\dy) -| (\ds-2*\di,0 |- S4D);
\draw (S5D) -- (S5D -| \ds+2*\di,0);
\pdot{S5D -| \ds+2*\di,0}
\pdot{\ds-2*\di,0 |- S4D}
\draw[->] (S3S) -- (S3D);
\draw[->] (S3D) -| (2*\ds-\di,0) -- (S3S);
\draw[->] (S3D) -| (\di+2*\ds,1.5) -| (S1S);
\setTrueFalseLabels{S3D};
\begin{pgfonlayer}{background}
\node[asmB, fit=(S1S) (S1D)] (S1) {};
\node[asmB, fit=(S2S) (S2D1)] (S2) {};
\node[asmB, fit=(S3S) (S3D)] (S3) {};
\node[asmB, fit=(S4S) (S4D)] (S4) {};
\node[asmB, fit=(S5S) (S5D)] (S5) {};
\end{pgfonlayer}
\draw (S1.south west) node[anchor=south west]{$S_1$};
\draw (S2.south west) node[anchor=south west]{$S_2$};
\draw (S3.south west) node[anchor=south west]{$S_3$};
\draw (S5.south west) node[anchor=south west]{$S_4$};
\draw (S4.south west) node[anchor=south west]{$S_5$};
\end{tikzpicture}
\caption{Toestandsgebaseerd ASM-schema van het leidend voorbeeld.}
\label{fig:aSMSchemaRunningExampleState}
\end{figure}
\section{Geheugencomponenten}
\label{s:memoryFSMD}
Alvorens we processoren kunnen implementeren zullen we eerst nieuwe componenten moeten introduceren. We zullen we deze componenten introduceren in een logische volgorde waarbij componenten gebruik maken van eerder ge\"introduceerde componenten.
\subsection{Register File Cell (RFC)}
Een \termen{register file cell} is een uitbreiding op een geklokte D-flipflop. Het component bevat een klok-ingang $\mbox{Clk}$, data-ingangen $D_{\mbox{\small{in}}1},\ldots,D_{\mbox{\small{in}}m}$, data-uitgangen $D_{\mbox{\small{out}}1},\ldots,D_{\mbox{\small{out}}n}$, \termen{leespoorten $\mbox{RE}_1,\mbox{RE}_{n}$} (ook wel ``\termen{Read-Enabled}'' genoemd) en \termen{schrijfpoorten $\mbox{WE}_1,\ldots,\mbox{WE}_{\left\lceil\log_2m+1\right\rceil}$} (ook wel ``\termen{Write-Enabled}'' genoemd). Deze ingangen laten ons toe om te kiezen uit welke data-ingang we data willen inlezen en deze bij de klokflank willen opslaan. We zullen data geklokt wegschrijven, net zoals bij een D-flipflop. Indien alle schrijfpoorten $\mbox{WE}_i=0$ lezen we geen nieuwe waarde in, en blijft de oude waarde behouden. In de andere gevallen dienen de schrijfpoorten een binaire getal $a$ te bepalen vanuit welke data-ingang $d_{\mbox{\small{in}}a}$ we data inlezen. Indien er voor het aantal data-ingangen $m$ geen natuurlijk getal $l$ bestaat zodat $l=\log_2 m+1$, zal er bij alle overige write-enable configuraties, data ingelezen worden uit de laatste data-ingang. Daarnaast kunnen we op eender welke uitgang de inhoud van het geheugen plaatsen. Vandaar dat er per uitgang ook een read-enable ingang is voorzien. Indien we een laag signaal aanleggen op een read-enable ingang $\mbox{RE}_i$, zal de overeenkomstige uitgang $D_{\mbox{\small{out}}i}$ hoog impedant zijn. De toestand van de uitgangen is niet geklokt: indien we tijdens twee klokflanken in een read-enable ingang aanpassen zullen we mits enige vertraging het resultaat op de data-uitgang zien, we hoeven dus niet op een klokflank te wachten. Op figuur \ref{fig:registerFileCell} tonen we een implementatie van een Register File Cell met $m=n=2$.
\begin{figure}[hbt]
\centering
\begin{tikzpicture}
\node[dff] (D) at (0,0) {};
\node[mux4to1,rotate=90] (M) at (-1.75,0 |- D.D) {};
\draw (M.output) -- (D.D);
\node[tris] (T1) at (1.75,0 |- D.Q) {};
\node[tris] (T2) at (2.5,-0.25) {};
\draw (D.Q) -- (T1.x);
\draw (D.Q -| 1.25,0) |- (T2.x);
\draw (D.Q -| 1.25,0) |- (-2.25,1.5) |- (M.data0);
\draw (M.data3) -| (M.data2 -| -2.25,0);
\draw (M.data1) -- ++(-1,0) node[anchor=east,scale=0.85]{$D_{\mbox{\small{in}}1}$};
\draw (M.data2) -- ++(-1,0) node[anchor=east,scale=0.85]{$D_{\mbox{\small{in}}2}$};
\draw (D.Clk) -| (-1,-2) node[anchor=north,scale=0.85]{Clk};
\draw (T1.z) -- (T1.z -| 3.5,0) node[anchor=west,scale=0.85]{$D_{\mbox{\small{out}}1}$};
\draw (T2.z) -- (T2.z -| 3.5,0) node[anchor=west,scale=0.85]{$D_{\mbox{\small{out}}2}$};
\draw (T1.c) -- (T1.c |- 0,-1.75) node[anchor=north,scale=0.85]{$\mbox{RE}_1$};
\draw (T2.c) -- (T2.c |- 0,-1.75) node[anchor=north,scale=0.85]{$\mbox{RE}_2$};
\draw (M.selout1) -- (M.selout1 |- 0,2) node[anchor=south,scale=0.85]{$\mbox{WE}_2$};
\draw (M.selout0) -| (-1.125,2) node[anchor=south,scale=0.85]{$\mbox{WE}_1$};
\pdot{D.Q -| 1.25,0};
\pdot{M.data2 -| -2.25,0};
\setIndexLabelsMuxD[west]{M};
\node[rectangle,draw=black,dashed,inner sep=0.3cm, fit=(M) (D) (T1) (T2)] (S1) {};
\end{tikzpicture}
\caption{Implementatie van een Register File Cell (RFC) met $2$ lees- en $2$ schrijfpoorten}
\label{fig:registerFileCell}
\end{figure}
\subsection{Registerbank}
Een belangrijke toepassing van een Register File Cell is een \termen{registerbank}. Een registerbank bevat verschillende register file cellen, die geordend worden in matrixstructuur. We spreken dan ook over een \termen{$m\times n$ registerbank} met $k$ \termen{schrijfpoorten} en $l$ \termen{leespoorten}. Dit betekent dat het component $m$ sequenties van $n$ bits opslaat. We kunnen hierbij data op $k$ verschillende sequenties tegelijk schrijven, en de inhoud van $l$ verschillende sequenties uitlezen. Hiervoor dienen we volgende in- en uitgangen te voorzien:
\begin{itemize}
 \item \termen{invoer-ingangen $I_{ij}$}: een set van $k\times n$ ingangen om $k$ sequenties van $n$ bits te kunnen inlezen in de registerbank.
 \item \termen{write-enable-ingangen $\mbox{WE}_i$}: $k$ verschillende signalen waarmee we aangeven of de invoer op $I_{ij}$ ingangen moet worden ingelezen.
 \item \termen{write-address-ingangen $\mbox{WA}_{ia}$}: $k$ groepen van $\lceil\log_2m\rceil$ bits waarmee we aangeven op welk adres we de $n$ bits die op $I_{ij}$ staan zullen wegschrijven.
 \item \termen{uitvoer-uitgangen $O_{ij}$}: een reeks van $l\times n$ signalen die we gebruiken om data in de registerbank uit te lezen.
 \item \termen{read-enable-ingangen $\mbox{RE}_i$}: $l$ signalen die bepalen of we op de uitgangen $O_{ij}$ iets zullen uitlezen. Analoog aan de write-enable-ingangen.
 \item \termen{read-address-ingangen $\mbox{RA}_{ia}$}: $l$ groepen van $\left\lceil\log_2m\right\rceil$ bits bepalen welke sequentie -- binair voorgesteld op de adres-ingangen -- wordt uitgelezen. Dit is analoog aan de write-address-ingangen.
\end{itemize}
Een registerbank omvat twee scenarios: het inlezen van data en het uitlezen van data. Indien we een hoog signaal aanleggen op $\mbox{WE}_i$, zullen we de data die op de ingangen $I_{ij}$ staan wegschrijven naar het adres dat binair ge\"encodeerd is met de write-access ingangen $\mbox{WA}_{ia}$ voor $j=0\ldots n-1$ en $a=0\ldots\left\lceil\log_2m\right\rceil-1$. Dit doen we op de klokflank. Indien we een laag signaal aan de write-enable ingang plaatsen, wordt de inhoud die op de bijbehorende invoer-ingangen staat genegeerd. Bij het uitlezen van data is het signaal van de read-enable-ingang van belang. Indien we een hoog signaal aanleggen op $\mbox{RE}_i$ zullen de uitvoer-uitgangen $O_{ij}$ de waardes van de data opgeslagen in een adres, binair gevormd door de read-address-ingangen $\mbox{WA}_{ia}$, aannemen voor $j=0\ldots n-1$ en $a=0\ldots\left\lceil\log_2m\right\rceil-1$. Indien we een laag signaal aanleggen, zijn deze uitvoer-uitgangen hoog impedant. Uitlezen van data gebeurt ongeklokt: indien we bijvoorbeeld de read-adress signalen aanpassen, zullen de uitvoer-uitgangen zich aanpassen ongeacht de toestand van de kok op dat moment. Tot slot beschouwen we vaak een speciaal geval van een registerbank: de \termen{dual port registerbank} is een registerbank met \'e\'en lees- en \'e\'en schrijfpoort. Bijgevolg is in dat geval $k=l=1$.
\begin{figure}[hbt]
\centering
\begin{tikzpicture}
\def\dy{-2.2 cm};
\def\dx{2.2 cm};
\def\ra{0.0725};
\def\rb{0.03625};
\foreach \a in {0,1} {
  \node[decoder2to4,rotate=90] (DW\a) at (-1.25*\dx,0.5*\dy+2*\a*\dy) {decoder};
%  \node[sigo] (SgW\a) at (-1.5*\dx,0 |- DW\a) {};
  \draw (DW\a.a0) -- ++(-0.5*\dx,0) node[anchor=east]{$\mbox{WA}_{\a0}$};
  \draw (DW\a.a1) -- ++(-0.5*\dx,0) node[anchor=east]{$\mbox{WA}_{\a1}$};
  \draw (DW\a.enable) |- ++(-0.5*\dx,\ra*\dy) node[anchor=east]{$\mbox{WE}_{\a}$};
}
\foreach \a in {0,1,2} {
  \node[decoder2to4,rotate=-90] (DR\a) at (3.5*\dx,0.5*\dy+\dy*\a) {decoder};
  \draw (DR\a.a0) -- ++(0.5*\dx,0) node[anchor=west]{$\mbox{RA}_{\a0}$};
  \draw (DR\a.a1) -- ++(0.5*\dx,0) node[anchor=west]{$\mbox{RA}_{\a1}$};
  \draw (DR\a.enable) |- ++(0.5*\dx,-\ra*\dy) node[anchor=west]{$\mbox{RE}_{\a}$};
}
\foreach \y in {0,...,3} {
  \foreach \x in {0,1,2} {
    \node[rfcbc] (RFC\y\x) at (\dx*\x,\dy*\y) {RFC};
  }
}
\foreach \x in {0,...,3} {
  \coordinate (MI\x0) at (DW0.s\x -| -0.5*\dx-4*\ra*\dx-\ra*\dx*\x,0);
  \coordinate (MI\x1) at (DW1.s\x -| -0.5*\dx-3*\ra*\dx+\ra*\dx*\x,0);
  \foreach \y in {0,1} {
    \draw (DW\y.s\x) -- (MI\x\y);
  }
  \foreach \y in {0,1,2} {
    \coordinate (MO\x\y) at (DR\y.s\x -| 2.5*\dx+\rb*\dx+4*\ra*\dx*\y+\ra*\dx*\x,0);
    \draw (DR\y.s\x) -- (MO\x\y);
  }
}
\foreach \y in {0,...,3} {
  \foreach \x/\p in {0/a,1/b,2/c} {
    \coordinate (RLH\y\x) at (0,\dy*\y+0.5*\dy-\rb*\dy-\ra*\dy*\x -| RFC\y2.re\p);
    \draw (RLH\y\x) -- (RLH\y\x -| RFC\y0.re\p);
    \foreach \z in {0,1,2} {
      \draw (RFC\y\z.re\p) -- (RLH\y\x -| RFC\y\z.re\p);
    }
    \foreach \z in {1,2} {
      \pdot{RLH\y\x -| RFC\y\z.re\p};
    }
  }
  \foreach \x/\p in {0/a,1/b} {
      \coordinate (WLH\y\x) at (0,\dy*\y-0.5*\dy+\rb*\dy+\ra*\dy+\ra*\dy*\x -| RFC\y0.we\p);
      \draw (WLH\y\x) -- (WLH\y\x -| RFC\y2.we\p);
      \foreach \z in {0,1,2} {
	\draw (RFC\y\z.we\p) -- (WLH\y\x -| RFC\y\z.we\p);
      }
      \foreach \z in {0,1} {
	\pdot{WLH\y\x -| RFC\y\z.we\p};
      }
    }
}
\foreach \x in {0,1,2} {
  \foreach \y/\p/\an in {0/a/west,1/b/north,2/c/east} {
    \coordinate (RLV\x\y) at (\dx*\x+0.5*\dx-\rb*\dx-\ra*\dx*\y,0 |- RFC0\x.dout\p);
    \draw (RLV\x\y) -- (RLV\x\y |- 0,3.75*\dy) node[anchor=\an,scale=0.95]{$O_{\y\x}$};
    
    \foreach \z in {0,1,2,3} {
      \draw (RLV\x\y |- RFC\z\x.dout\p) -- (RFC\z\x.dout\p);
    }
    \foreach \z in {1,2,3} {
      \pdot{RLV\x\y |- RFC\z\x.dout\p};
    }
  }
  \foreach \y/\p/\an in {0/a/east,1/b/west} {
    \coordinate (WLV\x\y) at (\dx*\x-0.5*\dx+\rb*\dx+\ra*\dx+\ra*\dx*\y,0 |- RFC3\x.din\p);
    \draw (WLV\x\y) -- (WLV\x\y |- 0,-0.75*\dy) node[anchor=\an,scale=0.95]{$I_{\y\x}$};
    \foreach \z in {0,1,2,3} {
      \draw (WLV\x\y |- RFC\z\x.din\p) -- (RFC\z\x.din\p);
    }
    \foreach \z in {0,1,2} {
      \pdot{WLV\x\y |- RFC\z\x.din\p};
    }
  }
}
\foreach \y in {0,...,3} {
  \foreach \x in {0,1} {
    \draw (MI\y\x) |- (WLH\y\x);
  }
}
\foreach \y in {0,...,3} {
  \foreach \x in {0,1,2} {
    \draw (MO\y\x) |- (RLH\y\x);
  }
}
\node[fit=(DR0) (DR1) (DR2) (DW0) (DW1) (RFC00) (RFC32),inner sep=0.625cm,draw=black,rectangle,dashed] {};
\end{tikzpicture}
\caption{Implementatie van een $4\times 3$ registerbank met $2$ schrijf- en $3$ leespoorten.??}
\label{fig:registerbank}
\end{figure}
\paragraph{}
Op figuur \ref{fig:registerbank} beschouwen we een $4\times 3$ registerbank met $2$ schrijf- en $3$ leespoorten. Bij de constructie van een registerbank met $k$ schrijf- en $l$ leespoorten, gebruiken we logischerwijs file register cellen met $k$ schrijf- en $l$ leespoorten. We zullen hier het kloksignaal negeren vermits de klokingang van de registerbank het kloksignaal enkel verderpropageert naar de klokingangen van alle register file cellen. We construeren vervolgens $k+l$ $m$-bit decoders te introduceren. Bij elk van de decoders verbinden we een read-enable $\mbox{RE}_i$ of write-enable $\mbox{WE}_i$ met de enable-ingang van de decoder. De read-address $\mbox{RA}_{ij}$ en write-address $\mbox{WA}_{ij}$ ingangen leggen vervolgens signalen aan op de adres-ingangen van de bijbehorende decoders.??
\paragraph{}
Verder zullen we ook een nieuwe notatie invoeren die we vanaf hier frequent zullen gebruiken: vaak zullen een groot aantal signalen parallell verschillende bits van het ene component naar het andere overbrengen. Vermits door de ori\"entatie van de het component meestal duidelijk is om welke signalen het gaat, zullen we niet elk signaal individueel tekenen. In dat geval stellen we de groep signalen voor met een brede lijn, en schrijven naast een dwarse streep het aantal signalen op die deze lijn voorstelt.
\subsection{Random Access Memory (RAM)}
Een variant van een registerbank is ``\termen{Random Access Memory (RAM)}''. De term ``\termen{Random Access}'' slaat op het feit dat we het geheugen niet sequentieel moeten uitlezen. We kunnen dus een adres meegeven die bepaald welke cellen we uitlezen. Verder wijkt een RAM ook af van ``Read-Only Memory (ROM)'' omdat we data naar het geheugen kunnen schrijven. Bij ROM branden we de data via een ingewikkelde procedure op de chip, waarna we enkel data kunnen uitlezen. Beide eigenschappen zijn ook eigen aan een registerbank. Indien we echter naar de implementatie van een registerbank kijken, is deze niet goedkoop. RAM geheugens bieden een gelijkaardige functionaliteit met minder hardware. Hiervoor bestaan er twee soorten implementaties:
\begin{itemize}
 \item \termen{Statisch RAM}: hier realiseren we een bit geheugen met een flipflop (wat dus neerkomt op 4 tot 6 transistoren per bit).
 \item \termen{Dynamisch RAM}: een implementatie met behulp van een condensator. Indien er stroom op de condensator staat bevat de cel een 1, in het ander geval een 0. Dynamisch RAM heeft de eigenschap dat door de data van een bit op te vragen, we de stroom uit de condensator halen, en deze dus opnieuw moeten opladen. Daarnaast kent een condensator ook lekstroom, waardoor we aan een zekere frequentie de cellen die een 1 voorstellen terug moeten opladen.
\end{itemize}
Vermits we minder hardware per bit nodig hebben, zal RAM bepaalde functionaliteit van een registerbank niet aanbieden. Allereerst werkt RAM geheugen trager. Dit kan alleen al verklaard worden door een grotere adres-decoder - RAM geheugens zijn immers groter - en is dus niet geschikt voor het opslaan van tussenresultaten in processoren. Daarnaast heeft RAM-geheugen een \termen{gecombineerde lees-schrijfpoort $R/W^*$}. Om aan te geven dat we iets willen schrijven of uitlezen bevat RAM-geheugen daarnaast ook een \termen{Chip Select-ingang $CS$}. Deze ingang functioneert ook als een vorm van klok-ingang. RAM geheugen is bijgevolg niet geklokt\footnote{Of tenminste niet op de globale klok van de schakeling.}.
\paragraph{}
RAM-geheugens hebben complex tijdsgedrag. Daarom zullen we de twee scenario's: het uitlezen en wegschrijven van data bespreken samen met de verschillende vormen van vertraging. Verder zullen we ook enkele typische grenzen van vertragingstijden voor vergelijkbare RAM-geheugen geven in tabel \ref{tbl:rAMDelaySamples}.
\paragraph{Uitlezen van data}Hiervoor dienen we het adres op de adres-ingang aan te leggen en een hoog signaal op de Chip Select-ingang $\mbox{CS}$ en de lees-schrijfpoort $\mbox{R/W}^*$. Op het moment dat we dit doen, zal de data-uitgang\footnote{Meestal heeft RAM-geheugen geen enkele data-uitgang maar een reeks uitgangen waardoor we bijvoorbeeld 8 bit tegelijk kunnen uitlezen.} $\mbox{D}_{\mbox{\small{out}}}$ hoog impedant zijn. Na enige tijd zal er op deze uitgang een ongeldig signaal komen te staan dit wordt meestal veroorzaakt door de interne logica van het component. Vervolgens komt de werkelijke data op de data-uitgangen te staan. Kenmerkend zijn hier de \termen{toegangstijd $t_{\mbox{\small{AA}}}$} en de \termen{$\mbox{CS}$ toegangstijd $t_{\mbox{\small{ACS}}}$}. Het zijn de maximale tijdsverschillen tussen het aanleggen van het signaal en het verschijnen van de geldige data op de data-uitgangen. Stel dat de lees-schrijfpoort en de chip-select ingang al hoog aangestuurd worden, en we zetten een adres op de adres-ingang zal het hoogstens de tijd gespecificeerd door de toegangstijd duren alvorens er geldige data op data-uitgang komt te staan. Omgekeerd kan er ook een geldig adres op de adres-ingang staan en dienen we nog een hoog signaal op de $\mbox{CS}$- en $\mbox{R/W}^*$ aan te leggen. In dat geval duurt het hoogstens de $\mbox{CS}$ toegangstijd alvorens geldige data op de data-uitgang verschijnt. Eenmaal er geldige data op de data-uitgang verschijnt kunnen we deze uitlezen en ergens in de schakeling gebruiken. Om nieuwe data uit te lezen of weg te schrijven zullen we ofwel het adres moeten veranderen, ofwel de een laag signaal om de $\mbox{CS}$- of $\mbox{R/W}^*$-ingang aanleggen. Er treed enige vertraging op alvorens het signaal van de data-uitgang dan terugvalt op de hoog impedante toestand. Deze vertraging noemen we de \termen{\mbox{CE} Off to Output High Impedance State $t_{\mbox{\small{HZ}}}$}. Een laatste tijdseenheid is de \termen{leescyclustijd $t_{\mbox{\small{RC}}}$}. Deze vertraging bepaald de minimale duur van het volledige leesproces. Het specificeert de minimale tijd die tussen twee leesopdrachten ligt. Vaak is deze bij DRAM langer dan de som van alle vertragingen die we hierboven beschouwd hebben. Dit komt omdat we na het uitlezen van de data, de condensatoren terug moeten opladen. Een schematische voorstelling van deze tijden staat op figuur \ref{fig:timeRAMRead}.
\begin{figure}[hbt]
\centering
\subfigure[Uitlezen]{
\begin{tikzpicture}
\begin{wave}[0.5]{3}{5.71428}
 \nextwave{Adres} \knownS{}{0.6857} \known{Adres}{4} \knownE{}{1.02857}
 \nextwave[0.5]{$\mbox{CS}\cdot \mbox{R/W}^*$} \bitS{0}{0.6857} \bit{1}{4} \bitE{0}{1.02857}
 \nextwave[1.0]{$\mbox{D}_{\mbox{\small{out}}}$} \unknownbit{2.3571428} \unknown{0.5} \known{geldig}{2.3428572} \unknownbit{0.51428}
 \waveTime{1}{1}{1}{2}{0.5}{$t_{\mbox{\small{RC}}}$}
 \waveTime{1}{1}{3}{2}{-1}{$t_{\mbox{\small{AA}}}$}
 \waveTime{2}{1}{3}{2}{-2.5}{$t_{\mbox{\small{ACS}}}$}
 \waveTime{2}{2}{3}{3}{-2.5}{$t_{\mbox{\small{HZ}}}$}
\end{wave}
\end{tikzpicture}
\label{fig:timeRAMRead}}
\centering
\subfigure[Wegschrijven]{
\begin{tikzpicture}
\begin{wave}[0.5]{3}{5.71428}
 \nextwave{Adres} \knownS{}{0.6857} \known{Adres}{4} \knownE{}{1.02857}
 \nextwave[0.5]{$\mbox{CS}\cdot\left(\mbox{R/W}^*\right)'$} \bitS{0}{0.6857} \bit{1}{4} \bitE{0}{1.02857}
 \nextwave[1.0]{$\mbox{D}_{\mbox{\small{in}}}$} \knownS{-}{2.8571428} \known{geldig}{2.3428572} \knownE{-}{0.51428}
 \waveTime{1}{1}{1}{2}{0.5}{$t_{\mbox{\small{WC}}}$}
 \waveTime{2}{2}{3}{1}{-2.5}{$t_{\mbox{\small{DW}}}$}
 \waveTime{2}{2}{3}{2}{-2.5}{$t_{\mbox{\small{DH}}}$}
\end{wave}
\end{tikzpicture}
\label{fig:timeRAMWrite}}
\caption{Tijdsgedrag van RAM-geheugens.}
\end{figure}
\paragraph{Wegschrijven van data}
Een gelijkaardig scenario treed op bij het wegschrijven van data. Alleen beschouwen we hier de data-ingang\footnote{Vermits er bij het inlezen op data-uitgang een hoog-impedant signaal wordt aangelegd, combineren sommige RAM-geheugens de data-ingang en de data-uitgang. In dat geval kunnen de signalen dus in beide richtingen stromen. We gaan hier niet verder op in.} $\mbox{D}_{\mbox{\small{in}}}$. Opnieuw dienen we eerst het adres aan te leggen om de adres ingang. Verder zetten we een 0 op de lees-schrijfpoort om aan te geven dat we een schrijf-operatie uitvoeren, en zetten we een 1 op de Chip Select-ingang om aan te geven dat we een operatie zullen uitvoeren. Vervolgens kunnen we data op de data-ingang aanleggen. Wanneer we de correcte data wegschrijven is in principe irrelevant. Vanaf het moment dat we de operatie starten, zal het geheugencomponenten beginnen met data weg te schrijven. Als we data aan de data-ingang veranderen zal met enige vertraging de nieuwe data weggeschreven worden. We dienen alleen de tijdkarakteristieken van geheugencomponenten in het algemeen in de gaten te houden: de \termen{set-up-tijd $t_{\mbox{\small{DW}}}$} en de \termen{data houdtijd $t_{\mbox{\small{DH}}}$}. Kort voor het afronden van de operatie dient immers de data niet meer te veranderen aan de ingang van de data-ingang. Dit is de set-up tijd. Anderzijds dient de data bovendien nog een zekere periode na het afronden van de operatie te blijven staan: de houdtijd. Tot slot spreken we ook over een \termen{schrijf cyclustijd $t_{\mbox{\small{WC}}}$}. Dit is de minimale tijd dat het adres op de adres-ingang moet blijven staan en de chip select-ingang en lees-schrijfpoort dezelfde configuratie blijven behouden. Een schematische voorstelling van een schrijfoperatie staat op figuur \ref{fig:timeRAMWrite}. Typische vertragingen voor een $4\mbox{k}\times1$-RAM\footnote{Dit betekent dat het geheugencomponent 4096 adressen bevat en elk adres 1 bit bijhoudt.} geheugen voor SRAM en DRAM staan in tabel \ref{tbl:rAMDelaySamples}.
\begin{table}[hbt]
\centering
\begin{tabular}{cl|rr|rr}
\multirow{2}{*}{$\Delta t$}&\multirow{2}{*}{Vertraging}&\multicolumn{2}{c|}{2147H SRAM}&\multicolumn{2}{c}{MM5280 DRAM}\\
&&min&max&min&max\\
\hline
$t_{RC}$&cyclustijd lezen&35 ns&&400 ns&\\
$t_{AA}$&toegangstijd&&35 ns&&200 ns\\
$t_{ACS}$&$CS$ toegangstijd&&35 ns&&180 ns\\
$t_{HZ}$&$CS'\rightarrow Z$&0 ns&30 ns&0 ns&\\\hline
$t_{WC}$&cyclustijd schrijven&35 ns&&0 ns&\\
$t_{DW}$&data set-up-tijd&20 ns&&150 ns&\\
$t_{DH}$&data houdtijd&0 ns&&0 ns&\\
\end{tabular}
\caption{Typische vertragingstijden voor RAM-geheugens.}
\label{tbl:rAMDelaySamples}
\end{table}
\subsection{Geheugens met Impliciete Adressering}
RAM geheugens vereisen dat we een absoluut adres meegeven. In heel wat programmeertalen hebben we echter datastructuren beschikbaar die zonder expliciete adressen werken. We spreken dan over een \termen{stapelgeheugen} ofwel \termen{stack} en een \termen{buffergeheugen} ofwel \termen{queue}. Omdat deze datastructuren bijzonder nuttig zijn in sommige algoritmen, werden hiervoor ook hardware-equivalenten ontwikkeld. We zullen in de volgende subsubsecties eerst deze datastructuren bespreken en vervolgens een hardwarecomponent bouwen die deze structuren implementeert. Studenten met een uitgebreide kennis over deze datastructuren kunnen de definitie overslaan.
\subsubsection{Stack (LIFO: Last-In-First-Out)}
\paragraph{Definitie}Een stack ofwel stapelgeheugen is een datastructuur die een lineare lijst voorstelt. Alle methodes van de stapel kunnen enkel bewerkingen uitvoeren op de \'e\'en uiteinde van deze lijst: de \termen{top}. De lijst van aangeboden functionaliteiten verschilt nogal. Toch dient een stapel minstens volgende functionaliteiten aan te bieden:
\begin{itemize}
 \item \termen{push}: het toevoegen van een element aan de stapel. Dit element wordt dan de nieuwe top.
 \item \termen{pop}: het weghalen van het element die zich bij de top bevindt. Het element net onder de top wordt dan de nieuwe top.
 \item \termen{reset}: ook wel clear genoemd. Een operatie die de volledige stapel verwijdert. We kunnen dit opvatten als het herhalen van een pop-operatie totdat de stapel leeg is, in de meeste gevallen kunnen we deze operatie echter sneller uitvoeren.
 \item \termen{leeg/empty}: controleren of een stapel leeg is en dus geen enkel element bevat. Indien dit het geval is, kan men geen pop-operaties meer uitvoeren.
 \item \termen{vol/full}: controleren of het volledige geheugen van de stapel gebruikt wordt. Indien dit het geval is, kan men geen push-operaties meer uitvoeren. Deze functionaliteit wordt meestal niet in software-implementaties van stapels aangeboden vermits men het geheugen dynamisch kan uitbreiden tot het volledige RAM geheugen in gebruik genomen is. Een fenomeen die men doorgaans niet beschouwd in software.
\end{itemize}
In hardware is een element een hoeveelheid data met een vast aantal bits. Men spreekt over het ``\termen{Last-In-First-Out (LIFO)}''-principe omdat de elementen die het laatst aan een stapel toegevoegd worden (door middel van een push-operatie), de eerste elementen zijn die terug uit de stapel gehaald worden (door middel van een pop-operatie).
\paragraph{Conceptueel voorbeeld}
\begin{figure}[hbt]
\centering
\subfigure[Push 6]{
\begin{stackConcept}{}\scpush{6}\end{stackConcept}
}
\subfigure[Push 2]{
\begin{stackConcept}{6}\scpush{2}\end{stackConcept}
}
\subfigure[Pop]{
\begin{stackConcept}{6,2}\scpop{}\end{stackConcept}
}
\subfigure[Push 1]{
\begin{stackConcept}{6}\scpush{1}\end{stackConcept}
}
\subfigure[Pop]{
\begin{stackConcept}{6,1}\scpop{}\end{stackConcept}
}
\subfigure[Pop]{
\begin{stackConcept}{6}\scpop{}\end{stackConcept}
}
\caption{Conceptueel voorbeeld van een stapelgeheugen.}
\label{fig:stackConceptExample}
\end{figure}
We introduceren ook een conceptueel voorbeeld van een stapelgeheugen dat staat op figuur \ref{fig:stackConceptExample}. Initieel is de stapel leeg en bevat deze dus geen elementen. Vervolgens voeren we een push-operatie uit met als argument 6. Het gevolg is een stapel met als enig element 6. Daarna voeren we een push operatie uit met 2. We voegen dus 2 toe aan de top van de stapel. Hierna voeren we een pop-operatie uit. Vermits het laatste toegevoegde element -- die nog niet van de stapel is gehaald -- 2 is, zullen we 2 terugkrijgen. Bij de push-operatie van 1 voegen we 1 toe aan de stapel. De stapel heeft dan als top 1 en subtop 6. Tot slot voeren we twee pop-operaties uit. Omdat 1 het laatste toegevoegde element is, is dit het resultaat van de eerste pop-operatie. Tot slot zullen we ook 6 van de stapel halen.
\paragraph{Implementatie met een schuifregister}
We kunnen een stapel implementeren met behulp van een schuifregister. Voorwaarde is wel dat het geheugen dan niet bijzonder groot kan worden. Bij een push operatie zullen we in dat geval de bits van het element inschuiven en dit aantal bits naar links opschuiven. Bij een pop-operatie schuiven we dit aantal bits terug naar rechts, en stellen de meest rechtse bits dit element voor. Deze implementatie is vrij kostelijk: in \ref{sss:shiftregisters} hebben we reeds register ge\"implementeerd. Per bit geheugen hebben we een flipflop en enkele multiplexers nodig. Bij grote stapelgeheugens is deze kost onacceptabel. Daarom zullen we bij grote stapels meestal gebruik maken van RAM-geheugens.
\begin{figure}[hbt]
\centering
\subfigure[Push 6]{
\stackImpl{3}{3}{0}{}
}
\subfigure[Push 2]{
\stackImpl{3}{0}{1}{6}
}
\subfigure[Pop]{
\stackImpl{3}{1}{2}{6,2}
}
\subfigure[Push 1]{
\stackImpl{3}{0}{1}{6}
}
\subfigure[Pop]{
\stackImpl{3}{1}{2}{6,1}
}
\subfigure[Pop]{
\stackImpl{3}{0}{1}{6}
}
\caption{Demonstratie van een stapelgeheugen met tellers.}
\label{fig:stackConceptExample}
\end{figure}
\begin{figure}[hbt]
\centering
\begin{tikzpicture}[circuit logic US]
\def\ec{-5};
\def\epp{-5.25};
\def\er{-5.625};
\def\efe{-1};
\node[counterdbitrev] (CW) at (-3,1.5) {$\begin{array}{c}n+1\mbox{-bit}\\\mbox{schrijfteller}\end{array}$};
\node[mux2to1,rotate=90,scale=1.5,anchor=data0,thick] (M) at ($(CW.Q2)+(2.75,-0.25)$) {};
\draw[thick] (CW.Q2) -- (CW.Q2 |- M.data0);
\node[counterdbitrev] (CR) at (-3,-1.75) {$\begin{array}{c}n\mbox{-bit}\\\mbox{leesteller}\end{array}$};
\node (CRV) at (CR.D2 |- 0,-0.25) {$2^n-1$};\draw[thick] (CRV) -- (CR.D2);
\draw[thick] (CR.Q2) |- ++(2.5,-0.25);
\draw[decoration={sigo,lines={$n$}},decorate,thick] ($(CR.Q2)+(2.5,-0.25)$)  |- (M.data1);
\node[ramm,anchor=A] (R) at ($(M.output)+(0.75,0)$) {$\begin{array}{c}2^n\times w\mbox{-bit}\\\mbox{RAM}\end{array}$};
\draw[decoration={sigo,lines={$n$}},decorate,thick] (M.output) -- (R.A);
\node[not gate,scale=0.75,rotate=90] (N1) at ($(R.RW)+(-0.25,-1)$) {};%($(CR.Q2)+(0,-0.875)$)
\node[not gate,scale=0.75,rotate=-90] (N2) at (\er,0) {};
\node[nor gate,inputs={normal,normal,normal}] (NO) at ($(R.north)+(0,1)$) {};
\coordinate (FEO) at (\efe,0 |- NO.input 2);
\coordinate (FEOM) at (FEO |- M.data0);
\coordinate (CRD) at ($(CR.Q2)+(0,-0.75)$);
\coordinate (MRW) at (M.selin0 |- CRD);
\pdot{MRW};
\draw (M.selin0) -- (MRW);
\draw[decoration={sigo,lines={$n+1$}},decorate,thick] (CW.Q2 |- M.data0) -- (FEOM);
\draw[decoration={sigo,lines={$n$}},decorate,thick] (FEOM) -- (M.data0);
\pdot{FEO};\pdot{FEOM};
\draw[decoration={sigo,lines={$n+1$}},decorate,thick] (FEOM) -- (FEO);
\draw[decoration={sigo,lines={$n$}},decorate,thick] (FEO) -- (NO.input 2);
\node[anchor=east,scale=0.9] (IR) at (-7,0 |- CW.CLR) {Reset$^*$};\draw (IR) -- (CW.CLR);\draw (IR -| \er,0) -- (N2.input);\draw(N2.output) |- (CR.LD);\pdot{IR -| \er,0};
\node[anchor=east,scale=0.9] (IE) at (-7,0 |- CR.CEIN) {Enable};\draw (IE) -- (CR.CEIN);\draw (IE -| \ec,0) |- (CW.CEIN);\draw (IE -| \ec,0) |- ($(CR.Q2)+(2.5,-0.5)$) -| ($(R.CS)+(-0.625,0)$) -- (R.CS);\pdot{IE -| \ec,0};
\node[anchor=east,scale=0.9] (IPP) at (-7,0 |- CR.DU) {Push/Pop$^*$};\draw (IPP) -- (CR.DU);\draw (IPP -| \epp,0) |- (CW.DU);\draw (IPP -| \epp,0) |- ($(CR.Q2)+(2.5,-0.75)$) -| (N1.input); \draw (N1.output) -| ($(R.RW)+(-0.25,0)$) -- (R.RW);\pdot{IPP -| \epp,0};
\node[anchor=west,scale=0.9] (OF) at (5,0 |- CW.north east) {Full};\draw[decoration={sigo,lines={$1$ MSB}},decorate] (FEO) |- (OF);
\node[anchor=west,scale=0.9] (OE) at (5,0 |- NO.output) {Empty};\draw (NO.output) -- (OE);
\node[anchor=west,scale=0.9] (OD) at (R.D -| 5,0) {Data In/Out};\draw[decoration={sigo,lines={$w$}},decorate,thick] (R.D) -- (OD);
\node[fit=(R) (M) (CW) (CR) (N1) (N2) (NO) (MRW),inner sep=0.625cm,draw=black,rectangle,dashed] {};
\end{tikzpicture}
\caption{Implementatie van een stapelgeheugen met behulp van RAM-geheugen.}
\label{fig:stackImplRAM}
\end{figure}
\paragraph{Implementatie met RAM-geheugens}
Een goedkopere manier is gebruik maken van RAM-geheugens. Hierbij is de kost beperkt tot een 4 \`a 6 transistoren per bit. We realiseren dan een stapelgeheugen met behulp van een RAM-geheugen -- die tevens ook de grote van het stapelgeheugen bepaald -- en twee tellers: het \termen{leesadres} en het \termen{schrijfadres}. Indien het RAM-geheugen $2^n$ adressen kent, beschouwen we een $n$-bit leesteller en $n+1$-bit schrijftellers\footnote{Op die manier kunnen ze elk adres voorstellen. We voegen aan de schrijfteller een extra bit toe voor overflow.}. De schrijfteller staat initieel op $0$, de leesteller staat initeel op $2^n-1$. Wanneer we een push operatie uitvoeren schrijven we de data weg naar het adres voorgesteld door de schrijfteller, en verhogen we beide tellers. Bij een pop-operatie lezen we de data uit het RAM-geheugen op het adres voorgesteld door de leesteller. Vervolgens verlagen we beide tellers. Merk op dat we bij een push- en pop-operatie dus niet alle data in het RAM-geheugen moeten opschuiven. We verhogen en verlagen enkel de tellers. Indien we het volledige geheugen volgeschreven hebben, zal de schrijfteller op $2^n$ komen te staan\footnote{Vermits de schrijfteller een $n+1$-bit teller is.}. Dit betekent dus dat de $n+1$-de bit van die teller een hoog signaal bevat. We kunnen dit hoog signaal naar buiten brengen als een full-signaal. Op figuur \ref{fig:stackImplRAM} implementeren we dit stapelgeheugen. Indien het reset-signaal actief wordt, wordt de schrijfteller gereset en komt deze op 0 te staan, de leesteller voert een load-operatie uit en laad de waarde $2^n-1$ in. Bij een push-operatie wordt het push/pop$^*$ signaal hoog, hierdoor wordt het increment-signaal bij beide tellers geactiveerd en worden deze opgehoogd in de volgende klokflank. De multiplexer zal intussen de huidige waarde van de schrijfteller doorsturen naar het RAM-geheugen, die de waarde die op de data-ingangen staat zal inlezen en wegschrijven. Bij een pop-operatie ontvangen beide tellers een decrement-signaal, de multiplexer stuurt het leesadres door naar het RAM-geheugen die de waarde die op dit adres-staat op de data-uitgang zal zetten. Ons component bevat daarnaast nog een enable-ingang: indien deze op 0 staat, worden de tellers en het RAM-geheugen niet aangepast en gebeurt er dus niets. De full-uitgang brengt zoals eerder vermeld de hoogste bit van de schrijfteller naar buiten, en is hoog indien alle geheugenplaatsen opgebruikt zijn. Daarnaast bevat ons component ook een empty-uitgang. Deze voert een NOR-operatie uit op alle bits van de schrijfteller. Indien alle bits 0 zijn (en de teller dus op 0 staat) is de stapel leeg, en geeft empty dus een laag signaal. Tot slot kunnen we opmerken dat we voor de implementatie strikt genomen geen twee tellers nodig hebben. Vermits de leesteller telkens gelijk is aan de gedecrementeerde waarde schrijfteller (en modulo $2^n$), zouden we ook een combinatorische moduler kunnen voorzien die de waarde van de leesteller uit de schrijfteller afleid. In dit geval zal de vertraging van de pop-operaties wel groter worden.
\subsubsection{Queue (FIFO: First-In-First-Out)}
\paragraph{Definitie}Een queue of buffergeheugen is een datastructuur die een lineare lijst voorstelt. Deze lijst heeft twee uiteindes. Aan het ene uiteinde voegen we elementen toe bij een schrijfoperatie, aan het andere uiteinde zullen we bij een leesoperatie elementen weghalen. Zoals de naam al doet vermoeden heeft een queue hoofdzakelijk de taak om data te bufferen in de tijd\footnote{Men dient een buffergeheugen niet te verwarren met een buffer-component. Een buffercomponent staat in voor het gelijkmatig verdelen van de spanning over verschillende uitgangen (en buffert dus het elektrisch potentiaal).}. Dit kan bijvoorbeeld nuttig zijn indien we een component soms aan hoge snelheid invoer data krijgt (zogenaamde bursts) en men deze data niet aan dezelfde snelheid kan verwerken. Een queue dient minstens volgende functionaliteiten aan te bieden:
\begin{itemize}
 \item \termen{Write} (ofwel enqueue): het inlezen van data en dit aan \'e\'en uiteinde van het buffergeheugen plaatsen.
 \item \termen{Read} (ofwel dequeue): het uitlezen van data aan het andere uiteinde van het buffergeheugen.
 \item \termen{Reset}: het buffergeheugen in de initi\"ele toestand plaatsen (waarbij het dus geen elementen bevat). Dit kan opgevat worden als het herhalen van read operaties tot alle elementen uit de queue verdwenen zijn.
 \item \termen{Full}: een indicator of alle beschikbare geheugenlocaties bezet zijn.
 \item \termen{Empty}: een indicator dat het buffergeheugen leeg is.
\end{itemize}
In hardware is een element een hoeveelheid data met een vast aantal bits. Men spreekt over het ``\termen{First-In-First-Out (LIFO)}''-principe omdat de elementen die het eerst aan een queue toegevoegd worden (door middel van een write-operatie), de eerste elementen zijn die terug uit de queue gehaald worden (door middel van een read-operatie).
\begin{figure}[hbt]
\centering
\subfigure[Write 6]{
\begin{queueConcept}{4}{}\qupush{6}\end{queueConcept}
}
\subfigure[Write 2]{
\begin{queueConcept}{4}{6}\qupush{2}\end{queueConcept}
}
\subfigure[Read]{
\begin{queueConcept}{4}{6,2}\qupop{}\end{queueConcept}
}
\subfigure[Write 1]{
\begin{queueConcept}{4}{2}\qupush{1}\end{queueConcept}
}
\subfigure[Read]{
\begin{queueConcept}{4}{2,1}\qupop{}\end{queueConcept}
}
\subfigure[Read]{
\begin{queueConcept}{4}{1}\qupop{}\end{queueConcept}
}
\caption{Conceptueel voorbeeld van een buffergeheugen.}
\label{fig:queueConceptExample}
\end{figure}
\paragraph{Conceptueel voorbeeld}
Analoog aan het stapelgeheugen introduceren we een conceptueel voorbeeld voor een buffergeheugen op figuur \ref{fig:queueConceptExample}. We voeren dezelfde operaties uit als bij het stapelgeheugen (push is write en pop is read). Toch zien we dat de elementen op een andere manier uit de datastructuur verdwijnen. Aanvankelijk is de queue leeg. Vervolgens plaatsen we met write operaties een 6 en een 2 in de queue. Bij de read operatie zullen we in tegenstelling tot bij een stapel, de 6 uit het geheugen halen.
\begin{figure}[hbt]
\centering
\subfigure[Push 6]{
\queueImpl{2}{0}{0}{}
}
\subfigure[Push 2]{
\queueImpl{2}{0}{1}{6}
}
\subfigure[Pop]{
\queueImpl{2}{0}{2}{6,2}
}
\subfigure[Push 1]{
\queueImpl{2}{1}{2}{6}
}
\subfigure[Pop]{
\queueImpl{2}{1}{3}{6,1}
}
\subfigure[Pop]{
\queueImpl{2}{2}{3}{6}
}
\caption{Demonstratie van een buffergeheugen met tellers.}
\label{fig:queueConceptExample}
\end{figure}
\paragraph{Implementatie met RAM-geheugens}
Analoog kunnen we ook een buffergeheugen implementeren met behulp van een RAM-geheugen en een lees- en schrijfteller. De schrijfteller houdt de positie bij van het uiteinde van de rij, waar we elementen zullen bijschrijven. De leesteller houdt de positie van het andere uiteinde bij, waar we elementen zullen uitlezen. We gebruiken het RAM-geheugen op een manier waarbij we de elementen niet dienen te verplaatsen. Dit kunnen we doen door zowel de lees als de schrijfteller aanvankelijk op 0 te zetten. Indien we een schrijf-operatie dienen uit te voeren, schrijven we het elementen op het adres gespecificeerd door de schrijfteller, en incrementeren we deze teller. Bij een lees-operatie lezen we de locatie van het geheugen uit en incrementeren we de leesteller. Indien \'e\'en van de tellers aan het einde van het geheugen komt, voeren we eenvoudigweg een wrap-around uit, en schrijven we dus opnieuw op het begin van het geheugen. Een probleem stelt zich op het moment dat de lees- en schrijftellers beide dezelfde waarde hebben. In dat geval zijn er immers twee situaties mogelijk: ofwel zijn op dat moment alle geheugencellen bezet, ofwel is op dat moment het buffergeheugen leeg (zoals bijvoorbeeld bij de initi\"ele toestand van de tellers). We verhelpen dit probleem opnieuw door bij een $2^n\times w$-bit RAM geheugen, de tellers uit te breiden naar $n+1$-bit tellers. De hoogste bit wordt niet gebruikt om het adres voor het RAM-geheugen aan te wijzen, we beschouwen voor adressering dus enkel de laagste $n$ bits. Indien deze $n$ laagste bits van de lees- en schrijfteller aan elkaar gelijk zijn, speelt zich opnieuw het scenario van vol of leeg af. Indien daarenboven de hoogste bits aan elkaar gelijk zijn, is de queue leeg, indien ze niet gelijk zijn is het buffergeheugen vol. Het conceptueel principe van deze tellers staat op figuur \ref{fig:queueConceptExample}. Op figuur \ref{fig:queueImplRAM} implementeren we een schakeling die een buffergeheugen realiseert. Vermits de tellers in \'e\'en richting tellen, makken we gebruik van uptellers. Indien de enable-inang hoog is, zal afhankelijk van het signaal aan de \mbox{\termen{read/write$^*$-ingang}} \'e\'en van de tellers een increment uitvoeren. Verder bepaald deze ingang ook, welke teller de multiplexer naar het RAM-geheugen doorstuurd. De multiplexer stuurt wel enkel de laagste $n$ bits door. De enable ingang zal verder ook het RAM-geheugen activeren. Indien de reset-ingang geactiveerd is, zullen beide tellers terug de initi\"ele waarde 0 krijgen. Tot slot implementeren we de indicators zoals eerder besproken: een buffergeheugen is leeg indien alle $n+1$ bits van de twee tellers gelijk zijn. Een buffergeheugen is vol indien op de hoogste bits na de tellers gelijk zijn.
\begin{figure}[hbt]
\centering
\begin{tikzpicture}[circuit logic US]
\def\el{-6.75};
\def\ela{5.25};
\def\ec{-5.125};
\def\epp{-6.125};
\def\epq{-6.375};
\def\er{-5};
\def\efe{-1.25};
\def\eff{2.75};
\def\af{3.5};
\def\afa{3.25};
\def\afb{3};
\node[upcounterdbit,minimum width=3cm] (CW) at (-3,1.5) {$\begin{array}{c}n+1\mbox{-bit}\\\mbox{schrijfteller}\end{array}$};
\node[mux2to1,rotate=90,scale=1.5,anchor=data0,thick] (M) at ($(CW.Q2)+(3,-0.5)$) {};\setIndexLabelsMuxB[west]{M};
\draw[thick] (CW.Q2) -- (CW.Q2 |- M.data0);
\node[upcounterdbit,minimum width=3cm] (CR) at (-3,-1.75) {$\begin{array}{c}n+1\mbox{-bit}\\\mbox{leesteller}\end{array}$};
\draw[thick] (CR.Q2) |- ++(\eff,-0.25);
\draw[decoration={sigo,lines={$n$}},decorate,thick] ($(CR.Q2)+(\eff,-0.25)$)  |- (M.data1);
\node[ramm,anchor=A] (R) at ($(M.output)+(0.75,0)$) {$\begin{array}{c}2^n\times w\mbox{-bit}\\\mbox{RAM}\end{array}$};
\draw[decoration={sigo,lines={$n$}},decorate,thick] (M.output) -- (R.A);
\node[and gate,anchor=output] (AR) at (CR.CEIN -| \ec,0) {};\draw (AR.output) -- (CR.CEIN);
\node[and gate,inputs={inverted,normal},anchor=output] (AW) at (CW.CEIN -| \ec,0) {};\draw (AW.output) -- (CW.CEIN);
\node[comp,rotate=90,thick,anchor=north,xshift=-0.125cm] (CO) at (R.west |- CW.CEIN) {Comp};
\node[xor gate,anchor=south,yshift=0.25cm] (X) at (CO.east) {};
\node[and gate,anchor=input 1] (A0) at (X -| \af,0) {};\draw (A0.output) -- (A0.output -| \ela,0) node[anchor=west]{Full};
\node[and gate,inputs={inverted,normal},anchor=input 2] (A1) at (CO -| \af,0) {};\draw (A1.output) -- (A1.output -| \ela,0) node[anchor=west]{Empty};
\draw (X.output -| \afa,0) |- (A1.input 1);\pdot{X.output -| \afa,0};\draw (CO.eq -| \afb,0) |- (A0.input 2);\pdot{CO.eq -| \afb,0};
\coordinate (FEO) at (\efe,0 |- CR.CEIN);
\coordinate (FEOM) at (FEO |- M.data0);\coordinate (FEOC) at (FEO |- CO.y1);\draw[decoration={sigo,lines={$n+1$}},decorate,thick] (FEOM) -- (FEOC);\pdot{FEOC};\draw[decoration={sigo,lines={$n+1$}},decorate,thick] (FEOC) -- (CO.y1);\draw (FEOC) |- (X.input 1);
\coordinate (FFO) at ($(CR.Q2)+(\eff,-0.25)$);
\coordinate (FFOM) at (FFO |- M.data1);\coordinate (FFOC) at (FFO |- CO.x1);\draw[decoration={sigo,lines={$n+1$}},decorate,thick] (FFOM) -- (FFOC);\pdot{FFOC};\draw[decoration={sigo,lines={$n+1$}},decorate,thick] (FFOC) -- (CO.x1);\draw (FFOC) |- (X.input 2);
\coordinate (CRD) at ($(CR.Q2)+(0,-0.75)$);
\coordinate (MRW) at (M.selin0 |- CRD);
\pdot{MRW};\pdot{FFOM};
\draw (M.selin0) -- (MRW);
\draw[decoration={sigo,lines={$n+1$}},decorate,thick] (CW.Q2 |- M.data0) -- (FEOM);
\draw[decoration={sigo,lines={$n$}},decorate,thick] (FEOM) -- (M.data0);
\pdot{FEOM};
\node[anchor=east,scale=0.9] (IR) at (\el,0 |- CW.CLR) {Reset$^*$};\draw (IR) -- (CW.CLR);\draw (IR -| \er,0) |- (CR.CLR);\pdot{IR -| \er,0};
\node[anchor=east,scale=0.9] (IE) at (\el,0 |- AR.input 2) {Enable};\draw (IE) -- (AR.input 2);\draw (IE -| \epq,0) |- (AW.input 2);\draw (IE -| \epq,0) |- ($(CR.Q2)+(2.5,-0.5)$) -| ($(R.CS)+(-0.625,0)$) -- (R.CS);\pdot{IE -| \epq,0};
\draw (X.output) -- (A0.input 1);\draw (CO.eq) -- (A1.input 2);
\node[anchor=east,scale=0.9] (IPP) at (\el,0 |- AW.input 1) {Read/Write$^*$};\draw (IPP) -- (AW.input 1);\draw (IPP -| \epp,0) |- (AR.input 1);\pdot{IPP -| \epp,0};\draw (AR.input 1 -| \epp,0) |- (MRW) -| ($(R.RW)+(-0.25,0)$) -- (R.RW);\pdot{AR.input 1 -| \epp,0};
\node[anchor=west,scale=0.9] (OD) at (R.D -| \ela,0) {Data In/Out};\draw[decoration={sigo,lines={$w$}},decorate,thick] (R.D) -- (OD);
\node[fit=(R) (M) (CW) (CR) (CW) (AR) (AW) (MRW),inner sep=0.625cm,draw=black,rectangle,dashed] {};
\end{tikzpicture}
\caption{Implementatie van een buffergeheugen met behulp van RAM-geheugen.}
\label{fig:queueImplRAM}
\end{figure}
\section{Synthese van een Niet-Programmeerbare Processor}
\label{s:syntheseFSMD}
Nu we een ASM-schema gedefinieerd hebben en nieuwe geheugencomponenten ter beschikkingen hebben kunnen we eindelijk een processor implementeren. We vertrekken vanuit het ASM-schema, en zullen in subsectie \ref{ss:syntheseFSMDBasis} eerst een methode bespreken om op een mechanische manier een ASM-schema om te zetten in een processor. Deze methode leidt tot een straightforward resultaat, maar dit is verre van optimaal. In subsecties \ref{ss:syntheseFSMDController}, \ref{ss:syntheseFSMDDatapad} en \ref{ss:syntheseFSMDOptimal} zullen we dan ook optimalisaties bespreken om de processor goedkoper en effici\"enter te maken.
\subsection{Basisprincipes}
\label{ss:syntheseFSMDBasis}
\paragraph{Principes}
We kunnen door volgende principes toe te passen op het ASM-schema een processor bouwen:
\begin{enumerate}
 \item Elke variabele is een register
 \item Elke operatie komt overeen met een functionele eenheid (FU) die logischerwijs dezelfde opdracht uitvoert (indien er dus een optelling in het ASM-schema voorkomt, zullen we een opteller in het datapad plaatsen).
 \item Indien een operatie de waarde van een variabele nodig heeft, maken we een verbinding van de uitgang van het bijbehorende register naar de bijbehorende ingang van functionele eenheid.
 \item Indien het resultaat van een operatie wordt weggeschreven naar een variabele, bouwen we een verbinding van de uitgang van de bijbehorende functionele eenheid naar de data-ingang van het register.
 \item Indien data-ingangen of constanten ingelezen kunnen worden bij een variabele, bouwen we een verbinding tussen de data-ingang/constante en het bijbehorende register, tenzij de constante 0 is.
 \item Indien verschillende functionele eenheden waardes wegschrijven naar eenzelfde register, voorzien we een multiplexer om de waarde te kiezen.
 \item Elk ASM-blok komt overeen met een toestand van de controller.
 \item Voor elke test waarbij een variabele betrokken is, dienen we een combinatorische module te bouwen die op basis van de waarde van de registers de test kan uitvoeren. De uitgang van deze test module is \'e\'en van het status-signalen, en bijgevolg een deel van de controller-ingangen.
 \item De reset- en load-ingangen van de registers vormen samen met de selectie-ingangen de het instructiewoord: een deel van de uitgangen van de controller.
\end{enumerate}
\paragraph{Leidend voorbeeld}
Op basis van het ASM-schema op figuur \ref{fig:aSMSchemaRunningExample} op pagina \pageref{fig:aSMSchemaRunningExample} kunnen we een processor bouwen. In het ASM-schema is er sprake van vier variabelen: $X$, $Y$, $Z$ en $I$.
\begin{figure}[hbt]
\centering
\begin{sprocessor}{4}{x/$X$/1/2,y/$Y$/3/2,z/$Z$/3/2,i/$I$/1/2}{sa/{$\shlcmd 1$},de/$-1$,rca/$z_2z_1z_0x_3$,sb/{$\shlcmd 1$},rcb/$z_2z_1z_0x_3-D$,rcc/$y_2y_1y_01$}
\draw[thick] (RRx-1) -- ++(0,0.5) node[anchor=south] {$N$};
\draw[thick] (RRi-1) -- ++(0,0.5) node[anchor=south] {3};
\end{sprocessor}
\end{figure}
\subsection{Ontwerp Controller}
\label{ss:syntheseFSMDController}
\subsection{Minimaliseren Datapad}
\label{ss:syntheseFSMDDatapad}
\subsection{Andere optimalisaties}
\label{ss:syntheseFSMDOptimal}
\section{Tijdsgedrag}
\label{s:timeFSMD}