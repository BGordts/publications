\chapter{Niet-Programmeerbare Processoren}
\chapterquote{We accepteren nu het feit dat leren een levenslang proces is om op de hoogte te blijven van veranderingen. En de meest urgente taak is mensen te leren hoe te leren.}{Peter F. Drucker, Amerikaans management consultant en auteur (1909-)}
\begin{chapterintro}
In de twee vorige hoofdstukken hebben we componenten gebouwd met een beperkte functionaliteit. De combinatorische schakelingen laten ons toe om schakelingen te ontwerpen die een rekenkundige operatie uitvoeren, maar we hebben geen geheugen beschikbaar om tussenresultaten in op te slaan. Het hoofdstuk over sequenti\"ele schakelingen maakt het mogelijk om schakelingen te ontwerpen met een geheugen. De meeste problemen hebben echter zeer grote toestandsruimtes (een 32-bit getal heeft meer dan vier miljard toestanden). Daarom volstaan de methodes uit dit hoofdstuk niet om een component te ontwikkelen die iets functioneel doet. Daarvoor zullen we methodes op een hoger niveau introduceren, dat van een niet-programmeerbare processor. Een niet programmeerbare processor voert een algoritme uit die op voorhand gekend is. Hierdoor kunnen we optimaal gebruik maken van de hardware en zoveel mogelijk instructies tegelijk uitvoeren. Het nadeel is dat eenmaal de processor geproduceerd is, we geen andere problemen met het component kunnen uitvoeren.
\end{chapterintro}
\minitoc[n]
\section{De Niet-Programmeerbare Processor}
Alvorens we de bouw van zo'n processor verder uitwerken, dienen we eerst enkele concepten te formaliseren. Allereerst ontleden we in deze sectie uit welke delen zo'n processor is opgebouwd. Vervolgens zullen we in sectie \ref{s:descriptionFSMD} een methode ontwikkelen om een algoritme formeel weer te geven. Deze beschrijving zal toelaten het algoritme later om te zetten naar een processor. In sectie \ref{s:memoryFSMD} ten slotte zullen we extra geheugencomponenten introduceren die we nodig zullen hebben bij de bouw van een processor.
\subsection{Algemene Structuur}
Een \termen{Niet-programmeerbare processor}, ofwel \termen{Finite State Machine with Data path (FSMD)} bestaat grofweg uit twee delen:
\begin{itemize}
 \item Een \termen{datapad}: een component die bewerkingen (rekenkundig, aritmetisch,...) uitvoert en de resultaten opslaat in tijdelijk geheugen.
 \item Een \termen{controller}: een component die het datapad aanstuurt. Het zegt welke actie op welk moment moet ondernomen worden.
\end{itemize}
In dit hoofdstuk is de controller niet programmeerbaar. Dat wil zeggen dat de controller telkens hetzelfde programma uitvoert. Dit betekent echter niet dat er een vaste cyclus in de controller zit. De controller kan afhankelijk van de waarden die in de geheugens van het datapad zitten, of van ingangen van de processor beslissen om andere acties te ondernemen. Een controller is dus een sequenti\"ele schakeling ofwel finite state machine. De synthese van een finite state machine werd in het hoofdstuk \ref{ch:SeqComp} reeds besproken. Uiteraard zullen we de karakteristieken die eigen zijn aan controllers in dit hoofdstuk bespreken.
\paragraph{}
Het spreekt voor zich dat de controller en het datapad continu data met elkaar uitwisselen. Enerzijds geeft de controller instructies aan het datapad. De groep signalen waarmee een controller een datapad aanstuurt noemen we het ``\termen{instructiewoord}'' ofwel ``\termen{controle-signalen}''. Anderzijds zullen de instructies vaak afhangen van de toestand van variabelen opgeslagen in het datapad. De verzameling van signalen die het datapad over zijn variabelen doorstuurt naar de controller noemen we ``\termen{statussignalen}''.
\paragraph{}
Een processor voert operaties uit op data. Deze data moet op de een of andere manier ingelezen worden in de processor. De verzameling ingangen waarmee we data vanuit de omgeving in het datapad injecteren noemen we de ``\termen{data-ingangen}''. Verder zullen we vaak ook informatie aan de controller moeten meedelen: we denken bijvoorbeeld aan een signaal die actief wordt wanneer alle data ingelezen is, en het algoritme kan uitgevoerd worden. Deze signalen noemen we ``\termen{controle-ingangen}''. Daarnaast willen we ook de resultaten kunnen uitlezen. Hiervoor voorzien we een reeks signalen vanuit het datapad, deze signalen noemen we ``\termen{data-uitgangen}''. Tot slot zijn we soms ook ge\"interesseerd in de toestand van het algoritme. We zullen bijvoorbeeld enkel data uitlezen indien het algoritme afgelopen is. De controller kan informatie over het algoritme naar buiten brengen via ``\termen{controle-uitgangen}''. De verschillende informatiestromen tussen het datapad en de controller en de processor en zijn omgeving beschrijven we op figuur \ref{fig:processorInformationStreams}.
\begin{figure}[hbt]
\centering
\subfigure[Processor]{
\begin{tikzpicture}[scale=0.8]
\draw[gray,dashed,thick] (-2.5,-3) rectangle (2.5,3);
\draw (-2.5,0) node[rotate=-90,gray,anchor=south]{Processor};
\draw (-2.5,0) node[rotate=-90,gray,anchor=north]{Omgeving};
\node[rectangle,thick,draw=black,minimum width=2 cm,minimum height=0.75 cm] (D) at (0,2) {Datapad};
\node[rectangle,thick,draw=black,minimum width=2 cm,minimum height=0.75 cm] (C) at (0,-2) {Controller};
\draw[->,thick] (D.south -| 0.3333,0) to node[midway,sloped,above,scale=0.8]{status-signalen} (C.north -| 0.3333,0);
\draw[->,thick] (C.north -| -0.3333,0) to node[midway,sloped,above,scale=0.8]{instructiewoord} (D.south -| -0.3333,0);
\draw[<-,thick] (C.west) to node[below,midway,scale=0.8]{controle-ingangen} (-4.25,-2);
\draw[->,thick] (C.east) to node[below,midway,scale=0.8]{controle-uitgangen} (4.25,-2);
\draw[<-,thick] (D.west) to node[above,midway,scale=0.8]{data-ingangen} (-4.25,2);
\draw[->,thick] (D.east) to node[above,midway,scale=0.8]{data-uitgangen} (4.25,2);
\end{tikzpicture}
\label{fig:processorInformationStreams}}
\subfigure[Datapad]{
\begin{tikzpicture}[scale=0.8]
\draw[gray,dashed,thick] (-3.5,-3) rectangle (3.5,3);
\draw (-3.5,1.3) node[rotate=-90,gray,anchor=south]{Datapad};
\draw (-3.5,1.3) node[rotate=-90,gray,anchor=north]{Omgeving};
\node[rectangle,thick,draw=black,minimum width=2 cm] (T) at (0,1.25) {Tijdelijk geheugen};
\node[trapezium,thick,draw=black] (O) at (0,0) {Operatorverbindingen};
\node[rectangle,thick,draw=black,minimum width=2 cm] (F) at (0,-1.25) {Functionele eenheden};
\node[minimum width=2 cm] (RA) at (0,-2.5) {Resultaatverbindingen};
\node[minimum width=2 cm,white] (RB) at (0,2.5) {Resultaatverbindingen};
\draw[thick] (RA.north west) -- (O.bottom left corner |- RA.south) -- (RA.south east) -- ++(1,0) |- (RB.north west) -- (RB.south -| O.bottom left corner) -- (RB.south east) -- ++(0.5,0) |- (RA.north west);
\draw[thick,->] (RB) -- (T);
\draw[thick,->] (T) -- (O);
\draw[thick,->] (O) -- (F);
\draw[thick,->] (F) -- (RA);
\draw[<-,thick] (RA.west -| O.west) -- ++(-3,0);
\draw[<-,thick] (RB.west -| O.west) -- ++(-3,0);
\draw (-4,0) node[scale=0.8,anchor=south]{instructiewoord};
\draw (-4,-2.5) node[scale=0.8,anchor=south]{instructiewoord};
\draw (-4,2.5) node[scale=0.8,anchor=south]{externe-ingangen};
\draw (1.75,-3.5) node[scale=0.8,anchor=south]{externe-uitgangen};
\draw[<-,thick] (O.west) -- ++(-3,0);
\draw[->,thick] (RA) |- ++(3.5,-1);
\end{tikzpicture}
\label{fig:datapadInformationStreams}}
\caption{Opbouw van een processor en datapad.}
\end{figure}
\paragraph{}
Door de controle-ingangen wordt de definitie van ``niet-programmeerbaar'' natuurlijk vaag. We zouden immers het toestandswoord van de controller in grote mate laten afhangen van de invoer die de controle-ingangen. Hierdoor kunnen we de processor toch programmeren. Het onderscheid is dan ook eerder een common-sense.
\subsection{Het Datapad}
Zoals we reeds hebben vermeld, kunnen we een controller modelleren als een eindige toestandsautomaat ofwel finite state machine. Een datapad daarentegen bestaat uit verschillende componenten:
\begin{itemize}
 \item \termen{Functionele Eenheden} ofwel \termen{Functional Units (FU)}: dit zijn schakelingen die berekeningen en aritmetisch operaties uitvoeren. Dit zijn dus de componenten die we in hoofdstuk \ref{ch:combinatoric} hebben besproken: optellers, ALU, schuifoperator,... Uiteraard kunnen we ook zelf functionele eenheden bouwen op de manier die we gezien hebben.
 \item \termen{Tijdelijke geheugens}: dit zijn componenten die de waarden waarop we bewerkingen uitvoeren voor enkele klokcycli kunnen vasthouden. Dit zijn bijvoorbeeld de registerbanken en RAM die we in sectie \ref{s:memoryFSMD} zullen invoeren. Het zijn groepen van flipflops die ons toelaten om op een hoger niveau te redeneren.
 \item \termen{Verbindingen}: de tijdelijke geheugens en de functionele eenheden wisselen informatie uit. Daarom hebben we twee types verbindingen nodig:
 \begin{itemize}
  \item \termen{Operandverbindingen}: dit zijn verbindingen die de waardes van de tijdelijke geheugens overbrengen als operanden van de functionele eenheden. De waarde van een register kan op die manier bijvoorbeeld gebruikt worden bij een optelling.
  \item \termen{Resultaatverbindingen}: het is de bedoeling dat de resultaten vervolgens in een tijdelijk geheugen opgeslagen worden. Resultaatverbindingen transporteren de resultaten van de functionele eenheden terug naar de tijdelijke geheugens. Sommige uitvoer kan ook weggeschreven worden naar de data-uitgangen. Ook de invoer van de data-ingangen wordt door deze verbindingen verwerkt.
 \end{itemize}
 Het spreekt voor zich dat de verbindingen beslissen welke geheugens als operanden en resultaatgeheugens dienen. Daarom zullen we ze implementeren als bussen met multiplexers en 3-state buffers. Deze bussen zullen dan worden aangestuurd door de controller.
\end{itemize}
Dit concept beschrijven we op figuur \ref{fig:datapadInformationStreams}.
\paragraph{}
In het datapad doen we dan ook niets anders dan waardes uit het tijdelijke geheugen inlezen, er een operatie van een functionele eenheid op uitvoeren en vervolgens in een tijdelijk geheugen plaatsen. Dit proces noemen we ook wel de ``\termen{registertransfer}'' en formaliseren we als:
\begin{equation}
\mbox{register}_a\leftarrow\mbox{FU}_a\left(\mbox{register}_{a_1},\mbox{register}_{a_1},\mbox{register}_{a_2},\ldots,\mbox{register}_{a_n}\right)
\end{equation}
In het eerste hoofdstuk hebben we reeds vermeld dat we schakelingen bij het bouwen van een processor beschrijven op registertransfer-niveau. Dit betekent dat we bijvoorbeeld abstractie zullen maken van flipflops en zullen werken met registers. Ook zullen we details als het aantal bits die een opteller nodig heeft verwaarlozen. Deze nieuwe notatiestijl zullen we geleidelijk invoeren.
\section{Formeel Beschrijven van een Algoritme}
\label{s:descriptionFSMD}
Alvorens we een processor kunnen bouwen die een algoritme uitvoert, moeten we eerst een formeel algoritme kunnen opstellen. Dit algoritme vertrekt altijd vanuit een probleemstelling. Hoe we een probleemstelling omzetten naar een algoritme behoort niet tot de inhoud van deze cursus\footnote{Het omzetten van een probleem in een algoritme is geen exacte wetenschap. Het is een vaardigheid die wel geoefend kan worden. Hiervoor bestaan er andere cursussen.}. We zullen altijd stellen dat het algoritme vooraf gekend moet zijn.
\subsection{Leidend Voorbeeld: Deler}
Als leidend voorbeeld doorheen dit hoofdstuk zullen we een processor bouwen die natuurlijke getallen kan delen. Uiteraard zouden we hiervoor een combinatorische schakeling kunnen bouwen. We zullen echter een algoritme beschouwen om de berekening te maken. De processor heeft 2 4-bit ingangen die het deeltal en de deler inlezen. Verder bevat het ook een controle-ingang. Zolang we een laag signaal op de controle-ingang aanleggen betekent dit dat er geen correcte invoer op de data-ingangen staat. Pas wanneer we een hoog signaal aanleggen zal het algoritme dus een deling uitvoeren. Verder bevat de processor ook 2 4-bit uitgang om het quoti\"ent en de rest naar buiten te brengen, en een controle uitgang die hoog wordt op het moment dat het algoritme het quoti\"ent en de rest heeft berekend. Zolang de controle-uitgang dus laag is, is het algoritme nog bezig met de berekening. Verder zal de processor ook wachten totdat de controle-ingang eerst laag is geweest alvorens opnieuw te beginnen. We maken de assumptie dat de deler nooit gelijk is aan 0. Het algoritme die dan vervolgens het deeltal en de deler omzet in het quoti\"ent en rest staat op \algoref{alg:devisionFSMD}.
\begin{algorithm}[hbt]
\caption{Delen van twee $n$-bit getallen.}\label{alg:devisionFSMD}
\begin{algorithmic}[1]
\Function{Division}{$N,D$}
\State $Q\gets 0$
\State $R\gets 0$
\For{$I=n-1\mbox{ \textbf{to} }0$}
\State $R\gets R\shlcmd{}1$\Comment{Logische shift $R$ naar links over 1 positie}
\State $R\left[0\right]\gets N\left[n-1\right]$
\State $N\gets N\shlcmd{}1$\Comment{Logische shift $N$ naar links over 1 positie}
\State $Q\gets Q\shlcmd{}1$\Comment{Logische shift $Q$ naar links over 1 positie}
\If{$R\geq D$}
\State $R\gets R-D$
\State $Q\left[0\right]\gets 1$
\EndIf
\EndFor
\State \Return $\left(Q,R\right)$
\EndFunction
\end{algorithmic}
\end{algorithm}
We gaan niet in op de precieze werking van het algoritme. Indien we een index opvragen of zetten bij een variabele zoals $V\left[i\right]$ betekent dit dat we een operatie op de $i$-de bit uitvoeren. We tellen we van rechts naar links, $V[0]$ is dus de minst beduidende bit van $V$ die rechts staat in de encodering. Verder zullen we ook de subscript-notatie gebruiken wanneer we bits samen nemen. Zo betekent $v_2v_1w_2w_2v_2w_1$ dat we een getal samenstellen uit de eerste twee bits van $V$, gevolgd door de eerste en de derde bit van $W$, daarna volgen nog de derde bit van $V$ en de tweede bit van $W$. Dit algoritme is echter niet geschikt voor een processor. Een processor voert immers continu het programma uit. Bovendien wordt hier niet gewacht tot er invoer op de data-ingangen staat. Een laatste opmerking is dat we geen berekeningen op invoer kunnen uitvoeren. Anders zouden we immers de uitgangen van functionele eenheden met de ingangen van de processor verbinden. Daarom dienen we variabelen te introduceren die we $X$, $Y$ en $Z$. Daarom zullen we het algoritme herschrijven\footnote{Strikt genomen is dit geen algoritme meer, vermits het nooit eindigt en er geen echt resultaat is. Een betere bewoording is waarschijnlijk procedure.}. We beschouwen hierbij de controle-ingang $ci$ en de controle-uitgang $co$. De herschreven procedure staat in \algoref{alg:devisionFSMDRev}.
\begin{algorithm}[hbt]
\caption{Procedure voor het delen van twee $4$-bit getallen.}\label{alg:devisionFSMDRev}
\begin{algorithmic}[1]
\Procedure{Division}{}
\While{true}
\Repeat\label{algl:s1start}
\State $co\gets 0$
\State $X\gets N$
\State $Y\gets 0$
\State $Z\gets 0$
\Until{$ci$}\label{algl:s1stop}
\For{$I=3\mbox{ \textbf{to} }0$}\label{algl:s2start}
\State $Z\gets Z\shlcmd{}1$\Comment{Logische shift $Z$ naar links over 1 positie}
\State $Z\left[0\right]\gets X\left[3\right]$
\State $X\gets X\shlcmd{}1$\Comment{Logische shift $X$ naar links over 1 positie}
\State $Y\gets Y\shlcmd{}1$\Comment{Logische shift $Y$ naar links over 1 positie}
\If{$Z\geq D$}\label{algl:devisionFSMDComp}
\State $Z\gets Z-D$\label{algl:devisionFSMDSub}
\State $Y\left[0\right]\gets 1$
\EndIf
\EndFor\label{algl:s2stop}
\Repeat\label{algl:s3start}
\State $co\gets 1$
\State $Q\gets Y$
\State $R\gets Z$
\Until{$\neg ci$}\label{algl:s3stop}
\EndWhile
\EndProcedure
\end{algorithmic}
\end{algorithm}
\subsection{Toestandsbeschrijving}
Een eerste probleem dient zich aan hoe we de procedure omzetten in een reeks toestanden. De vraag is immers wat we in \'e\'en zo'n toestand zullen realiseren. Zo kunnen we \algoref{alg:devisionFSMDRev} uitvoeren en per instructie een nieuwe toestand bouwen. Als we echter het programma onder de loep nemen, zien we dat dit algoritme zich uitstekend leent om verschillende instructies samen uit te voeren. Allereerst voeren we in de \textbf{for}-lus hoofdzakelijke shift operaties uit. Deze shiftoperaties vinden plaats over een vast aantal posities. We dienen dus helemaal geen schuifoperator te implementeren, en kunnen eenvoudigweg schuiven met verbindingen. Vervolgens doen we ook aan bitmanipulaties. Omdat deze bitmanipulaties opnieuw op vaste plaatsen plaatsvinden kunnen we dit realiseren met behulp van verbindingen. De enige twee aspecten die enige logica vereisen is de test of $Z\geq D$ is (lijn \ref{algl:devisionFSMDComp}), en het eventueel aftrekken van $D$ uit $Z$ (lijn \ref{algl:devisionFSMDSub}). Daarnaast moeten we tijdens de uitvoer van de \textbf{for} lus ook controleren of $I\geq 0$. In dat geval dienen we immers nogmaals de for-lus uit te voeren. We kunnen dit echter controleren met een simpele OR-poort die alle bits van $I$ samenneemt. Indien minstens \'e\'en van de bits een 1 is, zal de OR-lus een 1 teruggeven, en dienen we dus nog een cyclus uit te voeren. Dit leidt ertoe dat we ons algoritme in drie toestanden opdelen:
\begin{enumerate}
 \item $S_0$: inlezen van invoer, initialiseren van variabelen en wachten totdat $ci$ hoog wordt (lijnen \ref{algl:s1start}-\ref{algl:s1stop}).
 \item $S_1$: uitvoeren van een cyclus van de \textbf{for} lus en $I$ met 1 verlagen (lijnen \ref{algl:s2start}-\ref{algl:s2stop}).
 \item $S_2$: resultaten op de uitgang plaatsen en wachten tot $ci$ laag wordt (lijnen \ref{algl:s3start}-\ref{algl:s3stop}).
\end{enumerate}
\subsection{Toestand-Actie Tabel}
Nu we de toestanden hebben vastgesteld kunnen we het algoritme verder formaliseren. Dit zouden we kunnen doen met een grafische voorstelling zoals we gedaan hebben met een eindige toestandsautomaat. Het probleem is dat een rij in het toestandsdiagram niet enkel de voorwaarden en eventuele uitgangen bevat, daarnaast dient het ook nog de acties die door het datapad moeten worden uitgevoerd weer te geven. Dit zou leiden tot een complex en chaotisch diagram. Daarom verkiezen we een tabel: de ``\termen{Toestand-Actie Tabel}''. De tabel bestaat grofweg uit drie gedeeltes:
\begin{itemize}
 \item de huidige toestand: de huidige toestand waarin de controller zich bevindt.
 \item Een toestandsgedeelte: die we kunnen vergelijken met de toestandstabel van een eindige toestandsautomaat. De tabel bevat volgende kolommen:
 \begin{itemize}
  \item condities (afhankelijk van controle- en status-signalen)
  \item de volgende toestand
  \item de uitvoer (van eventuele controle-uitgangen).
 \end{itemize}
 \item een controle-actie gedeelte. Dit gedeelte bevat twee kolommen:
 \begin{itemize}
  \item conditie: een set voorwaarden wanneer een bepaalde set acties (gespecificeerd in de volgende kolom) moet worden uitgevoerd.
  \item actie: afhankelijk van de conditie welke opdrachten uitgevoerd worden op de variabelen in een klokcyclus.
 \end{itemize}
\end{itemize}
Tabel \ref{tbl:stateActionTableRunningExample} toont de toestand-actie tabel van \algoref{alg:devisionFSMDRev}. Een belangrijke opmerking is dat het onderverdelen van toestanden in condities bij het toestandsgedeelte niet verder loopt bij het onderverdelen van diezelfde toestand in het controle-actie gedeelte. Dit betekent dus dat de conditie bij de volgende toestand niet de conditie bij de controle- en datapad-acties impliceert en omgekeerd. Concreet betekent dit dus dat indien $I>0$, dit niet betekent dat $z_2z_1z_0x_3<D$ of dat we de bijbehorende datapad-acties moeten uitvoeren. Het toestandsgedeelte en het controle-actie gedeelte zijn dus onafhankelijk en zijn enkel afhankelijk van de huidige toestand.
\begin{table}[hbt]
\centering
\begin{tabular}{c!{\vrule width 1pt}c|c|c!{\vrule width 1pt}c|c}
Huidige&\multicolumn{2}{c|}{Volgende toestand}&Uit-&\multicolumn{2}{c}{Controle- \& datapad-acties}\\
Toestand&Conditie&Toestand&gang&Conditie&Acties\\\noalign{\hrule height 1pt}
\multirow{4}{*}{$S_0$}&\multirow{2}{*}{$ci=0$}&\multirow{2}{*}{$S_0$}&\multirow{2}{*}{$co=0$}&&$X\gets N$\\
&&&&&$Y\gets 0$\\\cline{2-4}
&\multirow{2}{*}{$ci=1$}&\multirow{2}{*}{$S_1$}&\multirow{2}{*}{$co=0$}&&$Z\gets 0$\\
&&&&&$I\gets 3$\\\noalign{\hrule height 1pt}
\multirow{8}{*}{$S_1$}&\multirow{4}{*}{$I>0$}&\multirow{4}{*}{$S_1$}&\multirow{4}{*}{$co=0$}&\multirow{4}{*}{$z_2z_1z_0x_3<D$}&$Z\gets z_2z_1z_0x_3$\\
&&&&&$X\gets X\shlcmd 1$\\
&&&&&$Y\gets Y\shlcmd 1$\\
&&&&&$I\gets I-1$\\\cline{2-6}
&\multirow{4}{*}{$I=0$}&\multirow{4}{*}{$S_2$}&\multirow{4}{*}{$co=0$}&\multirow{4}{*}{$z_2z_1z_0x_3\geq D$}&$Z\gets z_2z_1z_0x_3-D$\\
&&&&&$X\gets X\shlcmd 1$\\
&&&&&$Y\gets y_2y_1y_01$\\
&&&&&$I\gets I-1$\\\noalign{\hrule height 1pt}
\multirow{6}{*}{$S_2$}&\multirow{3}{*}{$ci=0$}&\multirow{3}{*}{$S_0$}&$co=1$&&\\
&&&$Q=Y$&&\\
&&&$R=Z$&&\\\cline{2-4}
&\multirow{3}{*}{$ci=1$}&\multirow{3}{*}{$S_2$}&$co=1$&&\\
&&&$Q=Y$&&\\
&&&$R=Z$&&\\
\end{tabular}
\caption{Toestand-actie tabel van het leidend voorbeeld.}
\label{tbl:stateActionTableRunningExample}
\end{table}
\paragraph{Simulatie}Om ons meer vertrouwd te maken met het concept van een toestand-actie tabel zullen we een deling simuleren met behulp van de tabel. We zullen $N=12$ delen door $D=7$ op de processor en stap per stap kijken wat er verandert. Dit doen we met behulp van tabel \ref{tbl:stateActionTableRunningExampleSim}. Omdat we met bitoperaties werken zullen we alle variabelen in de tabel in binaire notatie zetten.
\begin{table}[hbt]
\centering
\begin{tabular}{c|c|c|c}
Toestand&Voldane Condities&Acties&Uitvoer\\\hline
\multirow{4}{*}{$S_0$}&\multirow{4}{*}{$ci=1$}&$X\gets N=1100$&\multirow{4}{*}{$co=0$}\\
&&$Y\gets0000$&\\
&&$Z\gets0000$&\\
&&$I\gets11$&\\\hline

\multirow{4}{*}{$S_1$}&\multirow{2}{*}{$I=11>00$}&$Z\gets z_2z_1z_0x_3=0001$&\multirow{4}{*}{$co=0$}\\
&&$X\gets X\shlcmd{} 1=1000$&\\
&\multirow{2}{*}{$z_2z_1z_0x_3=0001<D=0101$}&$Y\gets Y\shlcmd{} 1=0000$&\\
&&$I\gets I-1=10$&\\\hline

\multirow{4}{*}{$S_1$}&\multirow{2}{*}{$I=10>00$}&$Z\gets z_2z_1z_0x_3=0011$&\multirow{4}{*}{$co=0$}\\
&&$X\gets X\shlcmd{} 1=0000$&\\
&\multirow{2}{*}{$z_2z_1z_0x_3=0011<D=0101$}&$Y\gets Y\shlcmd{} 1=0000$&\\
&&$I\gets I-1=01$&\\\hline

\multirow{4}{*}{$S_1$}&\multirow{2}{*}{$I=01>00$}&$Z\gets z_2z_1z_0x_3-D=0001$&\multirow{4}{*}{$co=0$}\\
&&$X\gets X\shlcmd{} 1=0000$&\\
&\multirow{2}{*}{$z_2z_1z_0x_3=0110\geq D=0101$}&$Y\gets y_2y_1y_01=0001$&\\
&&$I\gets I-1=00$&\\\hline

\multirow{4}{*}{$S_1$}&\multirow{2}{*}{$I=00$}&$Z\gets z_2z_1z_0x_3=0010$&\multirow{4}{*}{$co=0$}\\
&&$X\gets X\shlcmd{} 1=0000$&\\
&\multirow{2}{*}{$z_2z_1z_0x_3=0010<D=0101$}&$Y\gets Y\shlcmd{} 1=0010$&\\
&&$I\gets I-1=11$&\\\hline

\multirow{3}{*}{$S_2$}&\multirow{3}{*}{$ci=0$}&&$co=1$\\
&&&$Q=Y=0010$\\
&&&$R=Z=0010$\\
\end{tabular}
\caption{Simulatie van het algoritme met behulp van de toestand-actie tabel (tabel \ref{tbl:stateActionTableRunningExample}).}
\label{tbl:stateActionTableRunningExampleSim}
\end{table}
We stellen dat vanaf dat we de simulatie beginnen, reeds de data reeds op de ingangen van de processor aangelegd staat. Bijgevolg is $ci=1$, $N=1100$ en $D=0101$. We maken verder ook een assumptie dat $X$, $Y$ en $Z$ 4-bit geheugens zijn, dit is redelijk vermits we uitsluitend bits in dit bereik gebruiken, en we geen schuifoperaties naar rechts uitvoeren waardoor hogere bits in het bereik zouden komen te liggen. $I$ is een 2-bit geheugen vermits het uitsluitend waardes tussen 0 en 3 moet aannemen. Initieel vertrekt de processor vanuit toestand $S_0$ we zien op die toestand-actie tabel dat in toestand $S_0$ de ingangen in de geheugens worden ingelezen. Vermits er data op de ingangen staat, krijgt $X$ de waarde van de teller $N=1100$. De overige variabelen worden ge\"initialiseerd zoals beschreven staat in de toestand-actie tabel. Omdat $ci=1$ kunnen we afleiden dat de volgende toestand $S_1$ is. Verder specificeert de tabel ook dat we een laag signaal op de controle-uitgang moeten aanleggen (momenteel staat er immers geen uitkomst op de uitgangen). In de volgende stap bevinden we ons in toestand $S_1$. We evalueren eerst de verschillende condities ??.
\subsection{ASM-Schema}
Zoals reeds gezegd is de visualisatie van een eindige toestandsautomaat niet toereikend om een algoritme weer te geven. Een grafisch voorstelling die we wel kunnen gebruiken is een ``\termen{Algorithmic-State-Machine Chart}'' ofwel ``\termen{ASM-schema}''.
\subsubsection{ASM-Elementen}
Een ASM-schema lijkt op een flow-chart en bestaat drie verschillende soorten ``\termen{ASM-elementen}'':
\begin{itemize}
 \item \termen{Toestandskader} ofwel \termen{state box}: dit is een set niet-conditionele toekenning. We stellen een toestandskader voor door middel van een rechthoek waarin we de toekenningen schrijven. De toekenningen in \'e\'en toestandskader worden parallel uitgevoerd. Daarnaast bevat een toestandskader ook de status- en data-uitgangen van de processor. Men maakt een onderscheid doordat toekenningen met een pijl ($\gets$) weergegeven worden en uitgangen met een gelijkheidsteken ($=$). Figuur \ref{fig:asmElementState} toont een voorbeeld van een toestandskader.
 \item \termen{Beslissingskader} ofwel \termen{decision box}: dit is de voorstelling van een bepaalde conditie. Een conditie wordt voorgesteld met behulp van een ruit, waarin de conditie wordt geschreven. Vanuit een beslissingskader vertrekken er twee pijlen: voor het geval waarin de voorwaarde waar of vals is. We noteren de pijlen dan ook respectievelijk met ``[True]'' en ``[False]'', soms wordt ook 1 en 0 gebruikt. Figuur \ref{fig:asmElementDecision} toont een voorbeeld van een beslissingskader.
 \item \termen{Conditioneel kader} ofwel \termen{conditional box}: Dit is een toestandskader die enkel onder voorwaarden gespecificeerd door een beslissingskader worden uitgevoerd. Ook deze toekenningen worden in parallel uitgevoerd. Verder bevat een conditioneel kader ook de conditionele uitvoer op de processoruitgangen. We noteren toekenningen en uitgangen op dezelfde manier als bij toestandskaders. Men stelt een conditioneel kader voor als een rechthoek met afgeronde hoeken. Figuur \ref{fig:asmElementConditional} toont een voorbeeld van een conditioneel kader.
\end{itemize}
\begin{figure}[hbt]
\centering
\subfigure[Toestandskader]{
\begin{tikzpicture}
%\node[asmS] (S) at (0,0) {$\begin{array}{c}\mbox{niet conditioneel commando 1}\\\mbox{niet conditioneel commando 2}\\\cdots\\\mbox{niet conditioneel commando $n$}\end{array}$};
\node[asmS] (S) at (0,0) {$\begin{array}{c}\mbox{variabele$_1\gets$ expressie$_1$}\\\cdots\\\mbox{variabele$_m\gets$ expressie$_m$}\\\mbox{uitgang$_1=$ expressie$_{m+1}$}\\\cdots\\\mbox{uitgang$_n=$ expressie$_{m+n}$}\end{array}$};
\draw[<-] (S) -- ++(0,1.5) node[anchor=south]{in};
\draw[->] (S) -- ++(0,-1.5) node[anchor=north]{uit};
\end{tikzpicture}
\label{fig:asmElementState}
}
\subfigure[Beslissingskader]{
\begin{tikzpicture}
\node[asmD] (D) at (0,0) {test};
\draw[<-] (D) -- ++(0,1.5) node[anchor=south]{in};
\draw[->] (D) -| ++(-1.75,-1.5) node[anchor=north]{uit 1};
\draw[->] (D) -| ++(1.75,-1.5) node[anchor=north]{uit 2};
\draw (-1.75,0) node[anchor=south west,scale=0.75]{[True]};
\draw (1.75,0) node[anchor=south east,scale=0.75]{[False]};
\end{tikzpicture}
\label{fig:asmElementDecision}
}
\subfigure[Conditioneel kader]{
\begin{tikzpicture}
%\node[asmC] (C) at (0,0) {$\begin{array}{c}\mbox{conditioneel commando 1}\\\mbox{conditioneel commando 2}\\\cdots\\\mbox{conditioneel commando $n$}\end{array}$};
\node[asmC] (C) at (0,0) {$\begin{array}{c}\mbox{variabele$_1\gets$ expressie$_1$}\\\cdots\\\mbox{variabele$_m\gets$ expressie$_m$}\\\mbox{uitgang$_1=$ expressie$_{m+1}$}\\\cdots\\\mbox{uitgang$_n=$ expressie$_{m+n}$}\end{array}$};
\draw[<-] (C) -- ++(0,1.5) node[anchor=south]{in};
\draw[->] (C) -- ++(0,-1.5) node[anchor=north]{uit};
\end{tikzpicture}
\label{fig:asmElementConditional}
}
\caption{Voorstelling van de verschillende ASM-elementen}
\label{fig:asmElementsEnum}
\end{figure}
\subsubsection{Het ASM-Blok}
Deze ASM-elementen worden gegroepeerd in een ``\termen{ASM-blok}''. Alle ASM-elementen die in eenzelfde ASM-blok zitten, worden dan in \'e\'en klokcyclus uitgevoerd. Hierdoor voorzien we per toestand in de Toestand-Actie tabel een ASM-blok. Het blok zelf moet dan specificeren wat er in de toestand gebeurt. We zullen dit component voorstellen met behulp van een vierkant met streepjeslijnen. Vermits alle acties in \'e\'en klokflank uitgevoerd worden, bevat elk ASM-blok exact \'e\'en toestandskader. Dit toestandskader bevat dan alle toekenningen en uitgangen die onafhankelijk van condities in die toestand worden uitgevoerd. Indien er geen onafhankelijke operaties zijn, is het vierkant leeg. Indien er naast onafhankelijke acties ook onafhankelijk acties gebeuren (zowel in het toestand- als het actie-gedeelte), zullen we vervolgens enkele beslissingskaders plaatsen. We voeren testen uit op variabelen in het datapad door middel van status-signalen en eventuele signalen aan de controle-ingangen. Vermits we al deze testen reeds in de toestand-actie-tabel hebben gedefinieerd kunnen we eenvoudig de toestand-actie-tabel omvormen tot een ASM-schema. Zo staat op figuur \ref{fig:aSMSchemaRunningExample} het ASM-schema voor het leidend voorbeeld.
\begin{figure}[hbt]
\centering
\begin{tikzpicture}
\def\ds{6};
\def\di{1.75};
\def\dy{-2};
\def\offset{1};
\node[asmS] (S1S) at (0,0) {$\begin{array}{c}X\gets N\\Y\gets 0\\Z\gets 0\\I\gets 3\\co=0\end{array}$};
\node[asmD] (S1D) at (0,\dy) {$ci=0$};
\draw[->] (S1S) -- (S1D);
\draw[->] (S1D) -| (-\di,0) -- (S1S);
\setTrueFalseLabels{S1D};

\node[asmS] (S2S) at (\ds,0) {$\begin{array}{c}X\gets N\\I\gets I-1\\co=0\end{array}$};
\node[asmD] (S2D1) at (\ds,\dy) {$z_2z_1z_0x_3<D$};
\draw[->] (S2S) -- (S2D1);
\node[asmC] (S2C1) at (\ds-\di,2*\dy) {$\begin{array}{c}Z\gets z_2z_1z_0x_3\\Y\gets Y\shlcmd{} 1\end{array}$};
\draw[->] (S2D1) -| (S2C1);
\node[asmC] (S2C2) at (\ds+\di,2*\dy) {$\begin{array}{c}Z\gets z_2z_1z_0x_3-D\\Y\gets y_2y_1y_01\end{array}$};
\draw[->] (S2D1) -| (S2C2);
\draw (S2C1) |- (\ds,2.5*\dy) -| (S2C2);
\node[asmD] (S2D2) at (\ds,3*\dy) {$I>0$};
\draw[->] (\ds,2.5*\dy) -- (S2D2);
\draw[->] (S1D) -| (\di,\offset) -| (S2S);
\draw[->] (S2D2) -| (\ds-2*\di,0) -- (S2S);
\setTrueFalseLabels{S2D1};
\setTrueFalseLabels{S2D2};

\node[asmS] (S3S) at (2*\ds,0) {$\begin{array}{c}co=1\end{array}$};
\node[asmD] (S3D) at (2*\ds,\dy) {$ci=1$};
\node[asmN] (N1) at (2*\ds,2*\dy) {$\begin{array}{c}Q=Y\\R=Z\end{array}$};
\draw[->] (S2D2) -| (\ds+2*\di,\offset) -| (S3S);
\draw[->] (S3S) -- (S3D);
\draw[->] (S3D) -| (2*\ds-\di,0) -- (S3S);
\draw[->] (S3D) -| (\di+2*\ds,1.5) -| (S1S);
\setTrueFalseLabels{S3D};
\begin{pgfonlayer}{background}
\node[asmB, fit=(S1S) (S1D)] (S1) {};
\node[asmB, fit=(S2S) (S2D1) (S2D2) (S2C1) (S2C2)] (S2) {};
\node[asmB, fit=(S3S) (S3D)] (S3) {};
\end{pgfonlayer}
\draw (S1.south west) node[anchor=south west]{$S_1$};
\draw (S2.south west) node[anchor=south west]{$S_2$};
\draw (S3.south west) node[anchor=south west]{$S_3$};
\end{tikzpicture}
\caption{ASM-schema van het leidend voorbeeld.}
\label{fig:aSMSchemaRunningExample}
\end{figure}
\subsubsection{Traditionele Valkuilen}
Traditioneel maakt men een aantal fouten tegen ASM-schemas. In deze subsubsectie zullen we een overzicht geven van de meest gemaakte fouten.
\begin{figure}[hbt]
\centering
\subfigure[Meerdere volgende toestanden]{
\begin{tikzpicture}
\node[asmS] (A0) at (0,0) {$A_0$};
\node[asmD] (T0) at (-1.75,-1.25) {$t_1$};
\node[asmD] (T1) at (1.75,-1.25) {$t_2$};
\node[asmS] (A1) at (-3,-2.375) {$A_1$};
\node[asmS] (A2) at (0,-2.375) {$A_2$};
\node[asmS] (A3) at (3,-2.375) {$A_3$};
\setTrueFalseLabels{T0};
\setTrueFalseLabels{T1};
\draw[->] (A0) -- (0,-0.5) -| (T0);
\draw[->] (0,-0.5) -| (T1);
\draw[->] (T0) -| (A1);
\draw[->] (T1) -| (A3);
\draw[->] (T0) -| (A2);
\draw[<-] (A0) -- ++(0,0.75);
\draw (T1) -| (0,-1.25);
\pdot{0,-0.5};
\pdot{0,-1.25};
\begin{pgfonlayer}{background}
\node[asmB, fit=(A0) (T0) (T1)] (S1) {};
\node[asmB, fit=(A1)] (S2) {};
\node[asmB, fit=(A2)] (S3) {};
\node[asmB, fit=(A3)] (S4) {};
\end{pgfonlayer}
\draw (S1.south west) node[anchor=south west]{$S_1$};
\draw (S2.south west) node[anchor=south west]{$S_2$};
\draw (S3.south west) node[anchor=south west]{$S_3$};
\draw (S4.south west) node[anchor=south west]{$S_4$};
\end{tikzpicture}
\label{fig:badASMMultipleFlows}
}
\subfigure[Geen volgende toestanden]{
\begin{tikzpicture}
\node[asmS] (A0) at (0,0) {$A_0$};
\node[asmD] (T0) at (0,-1.25) {$t_1$};
\node[asmS] (A1) at (1.25,-2.375) {$A_1$};
\setTrueFalseLabels{T0};
\draw[->] (A0) -- (T0);
\draw[->] (T0) -| (A1);
\draw[<-] (A0) -- ++(0,0.75);
\draw (T0) -| (-1.25,-0.5) -- (0,-0.5);
\pdot{0,-0.5};
\begin{pgfonlayer}{background}
\node[asmB, fit=(A0) (T0)] (S1) {};
\node[asmB, fit=(A1)] (S2) {};
\end{pgfonlayer}
\draw (S1.south west) node[anchor=south west]{$S_1$};
\draw (S2.south west) node[anchor=south west]{$S_2$};
\end{tikzpicture}
\label{fig:badASMNoFlows}
}
\subfigure[Meerdere toekenningen]{
\begin{tikzpicture}
\node[asmS] (A0) at (0,0) {$X\gets 0$};
\node[asmD] (T0) at (0,-0.75) {$t_1$};
\node[asmC] (A1) at (1.25,-1.5) {$X\gets 1$};
\node[asmS] (A2) at (0,-2.5) {$A_0$};
\setTrueFalseLabels{T0};
\draw[->] (A0) -- (T0);
\draw[->] (T0) -| (A1);
\draw[<-] (A0) -- ++(0,0.75);
\draw[->] (T0) -| (-1.25,-2) -| (A2);
\draw (A1) |- (0,-2);
\pdot{0,-2};
\begin{pgfonlayer}{background}
\node[asmB, fit=(A0) (T0) (A1)] (S1) {};
\node[asmB, fit=(A2)] (S2) {};
\end{pgfonlayer}
\draw (S1.south west) node[anchor=south west]{$S_1$};
\draw (S2.south west) node[anchor=south west]{$S_2$};
\end{tikzpicture}
\label{fig:badASMMultipleAssignments}
}
\subfigure[Testen op nieuwe waarden]{
\begin{tikzpicture}
\node[asmS] (A0) at (0,0.25) {$a\gets a-1$};
\node[asmD] (T0) at (0,-0.75) {$a>3$};
\node[asmC] (A1) at (-1.25,-1.5) {$b\gets 2$};
\node[asmS] (A2) at (0,-2.5) {$A_0$};
\setTrueFalseLabels{T0};
\draw[->] (A0) -- (T0);
\draw[->] (T0) -| (A1);
\draw[<-] (A0) -- ++(0,0.75);
\draw[->] (T0) -| (1.25,-2) -| (A2);
\draw (A1) |- (0,-2);
\pdot{0,-2};
\begin{pgfonlayer}{background}
\node[asmB, fit=(A0) (T0) (A1)] (S1) {};
\node[asmB, fit=(A2)] (S2) {};
\end{pgfonlayer}
\draw (S1.south west) node[anchor=south west]{$S_1$};
\draw (S2.south west) node[anchor=south west]{$S_2$};
\end{tikzpicture}
\label{fig:badASMTests}
}
\subfigure[Gebruik nieuwe waarde]{
\begin{tikzpicture}
\node[asmS] (A00) at (0,0) {$y\gets x+1$};
\node[asmS] (A01) at (0,-1) {$z\gets y+2$};
\draw[->] (0,0.75) -- (A00);
\draw[->] (A00) -- (A01);
\draw[->] (A01) -- (0,-1.75);
\node (A) at (1.5,-0.5) {$\neq$};
\node[asmS] (A1) at (3,-0.5) {$\begin{array}{c}y\gets x+1\\z\gets y+2\end{array}$};
\draw[->] (3,0.75) -- (A1);
\draw[->] (A1) -- (3,-1.75);
\end{tikzpicture}
\label{fig:badASMUsage}
}
\subfigure[Conditioneel na toestandskader]{
\begin{tikzpicture}
\node[asmS,minimum width=3cm] (A00) at (0,0) {$A_0$};
\node[asmC,minimum width=3cm] (A01) at (0,-1) {$A_1$};
\draw[->] (0,0.75) -- (A00);
\draw[->] (A00) -- (A01);
\draw[->] (A01) -- (0,-1.75);
\end{tikzpicture}
\label{fig:badCAfterS}
}
\subfigure[Toewijzen uitgang]{
\begin{tikzpicture}
\node[asmS] (A1) at (3,-0.5) {$\mbox{uitgang}\gets\mbox{expressie}$};
\draw[->] (3,0.75) -- (A1);
\draw[->] (A1) -- (3,-1.75);
\end{tikzpicture}
}
\caption{Traditionele valkuilen bij het maken van ASM-schema's.}
\label{fig:badASM}
\end{figure}
\paragraph{Meerdere volgende toestanden}Men kan in een ASM-schema een flow chart tekenen waarbij onder bepaalde condities, men twee verschillende pijlen kan volgen. Een voorbeeld van zo'n flow chart staat op figuur \ref{fig:badASMMultipleFlows}. Indien bijvoorbeeld test $t_1$ slaagt en $t2$ faalt, dienen we de stromen naar $A_1$ \'en $A_3$ te volgen. Dit is niet zo problematisch wanneer dit in hetzelfde ASM-blok gebeurd (we kunnen argumenteren dat we dan alle toewijzingen uit $A_1$ en $A_3$ uitvoeren). Indien we echter later naar verschillende toestanden gaan krijgen we problemen. We kunnen dit probleem makkelijk verhelpen door geen vertakkingen met pijlen toe te staan. Enkel uit het beslissingskader vertrekken twee pijlen. Uit een toestands- en conditioneel kader vertrekt altijd slechts \'e\'en pijl. Het samenbrengen van pijlen is wel toegelaten.
\paragraph{Geen volgende toestand}Ook het omgekeerde kan voorkomen: een ASM-blok waarbij we geen volgende toestand bekomen bij een bepaalde situatie. Figuur \ref{fig:badASMNoFlows} toont een minimaal voorbeeld: indien aan $t_1$ wordt voldaan zullen we nooit naar een volgende toestand overgaan. Dit komt omdat de pijl nooit een toestandskader bereikt (en we dus in een volgende toestand komen. Ook dit probleem kunnen we eenvoudig voorkomen: in elk ASM-blok gaan alle mogelijke lussen doorheen het toestandskader.
\paragraph{Verschillende toekenningen aan dezelfde variabele} Tijdens \'e\'en klokflank kan een variabele slechts \'e\'enmaal van waarde veranderen. We kunnen in een ASM-blok echter meerdere kaders plaatsen die elk een waarde aan dezelfde variabele toekennen. Figuur \ref{fig:badASMMultipleAssignments} toont zo'n situatie: indien $t_1$ niet waar is, kennen we zowel $0$ als $1$ toe aan $X$. Men kan argumenteren dat $X$ dan de waarde $1$ krijgt, omdat dit de laatste toekenning is aan $X$ in het diagram. De componenten die in een ASM-blok staan kunnen dus vrij verandert worden in volgorde. Bovendien zullen we in sectie \ref{s:syntheseFSMD} een mechanisme ontwikkelen om deze ASM-schema's om te zetten in hardware. Incorrecte ASM-schema's zullen leiden tot implementatiefouten. We kunnen dit voorkomen door bij elk ASM-blok alle mogelijke paden te analyseren en te controleren dat geen variabele twee toewijzingen krijgt.
\paragraph{Testen van nieuwe waarde} Omdat alles in een ASM-blok tegelijk gebeurt zijn de waardes van variabelen ook nog niet aangepast wanneer we een toestandsblok verlaten. Zolang we ons echter nog in hetzelfde ASM-blok bevinden, zijn die aanpassingen nog niet doorgevoerd. Stel dat we bijvoorbeeld volgende \texttt{C} programma beschouwen:
\begin{verbatim}
a--;
if(a > 3) {
  b = 2;
}
\end{verbatim}
Dan kunnen we dit vertalen naar \'e\'en toestand in het ASM-schema. Figuur \ref{fig:badASMTests} is echter niet de juiste vertaling. Stel immers dat $a=4$ dan zal in het \texttt{C}-programma de \texttt{if}-lus niet uitgevoerd worden, $a$ heeft immers voor het \texttt{if}-statement de waarde $3$. In het ASM-schema krijgt $a$ ook de waarde $3$, maar alleen nadat we het ASM-blok verlaten hebben. Bijgevolg zal bij de voorwaarde $a$ nog steeds de waarde $4$ hebben. En zal de \texttt{if}-lus uitgevoerd worden. Een oplossing is om in dit geval gewoon te testen op $a-1>3$ of dus $a>4$.
\paragraph{Gebruiken van een nieuwe waarde} Een verwante traditionele fout is het gebruiken van de nieuwe waarde in de volgende berekening. Een voorbeeld van dit concept staat op figuur \ref{fig:badASMUsage}. Hier zien we twee ASM-schema's die niet equivalent zijn. Indien bijvoorbeeld $x=2$ en $y=1$ zal in de eerste flow $z=5$. In het tweede geval is $z=3$. Indien beide kaders in een verschillend ASM-blok of -element staan, is dit uiteraard toegelaten. Indien de toekenningen in hetzelfde ASM-element of ASM-blok staan, worden de opdrachten parallel uitgevoerd, en zullen we dus de oude waarde gebruiken. Men kan dit fenomeen testen door de volgorde van toekenningen in een ASM-element te wijzigen of de beslissingskaders en hun bijbehorende conditionele kaders anders te schikken. Nadat deze volgorde dan wijzigt, zou het programma nog steeds op dezelfde manier moeten werken.
\paragraph{Aanduiden van controller-uitgangen}We zijn reeds kort ingegaan op de notatie van uitgangen in de toestand- en conditionele kaders. We noteren de waarde van een uitgang met behulp van een gelijkheidsteken ($=$). Indien we de uitgang niet vermelden, staat er een 0 op die uitgang (in het geval van meerdere bits, zijn alle bits dus 0). Soms komt het ook voor dat een uitgang in elke toestand een combinatorische schakeling van enkele variabelen is. In dat geval moeten we deze uitgang niet in elk toestandskader vermelden, maar volstaat het om een nota te maken, zoals we ook op figuur \ref{fig:aSMSchemaRunningExample}. Deze nota is geen onderdeel van het ASM-schema, en wordt makkelijk vergeten.
\paragraph{Conditioneel kader na toestandskader}Een laatste fout die regelmatig terugkomt is het plaatsen van een conditioneel kader na een toestandskader zoals op figuur \ref{fig:badCAfterS}. Vermits er geen beslissingskader aan vooraf gaat, is dit conditioneel kader helemaal niet gebonden aan een voorwaarde. Dit probleem lossen we op door het conditioneel kader om te vormen tot een toestandskader. Indien beide kaders bovendien in eenzelfde ASM-blok staan, kunnen we de inhoud van beide kaders samennemen in \'e\'en toestandskader.
\subsubsection{Inputgebaseerde en Toestandsgebaseerde ASM-schema's}
We hebben het reeds kort gehad over het toekennen van toestanden aan delen van een programma besproken. Een belangrijk aspect daarbij is dat we ASM-schema's kunnen onderverdelen in twee categorie\"en:
\begin{itemize}
 \item \termen{Inputgebaseerd ASM-schema}: In dit schema kunnen we de waarde van testen (status-signale) en controle-ingangen onmiddellijk gebruiken. Een inputgebaseerd ASM-schema van het leidend voorbeeld stond op figuur \ref{fig:aSMSchemaRunningExample}.
 \item \termen{Toestandsgebaseerd ASM-schema}: Hierbij kunnen we de waardes van testen (status-signalen) en controle-ingangen pas in de volgende klokflank gebruiken. Het betekent dus dat elke voorwaardelijke uitvoering van een opdracht gepaard gaat met de overgang naar een nieuwe toestand. Bijgevolg bevat dit diagram ook geen conditionele kaders.
\end{itemize}
Inputgebaseerde ASM-schema's kunnen meer opdrachten uitvoeren in een klokflank, omdat we niet moeten wachten op het kloksignaal om conditionele operaties uit te voeren. Anderzijds zal dit ASM-schema tot een langere klokcyclus leiden. Dit komt omdat de testen eerst moeten berekend worden alvorens we sommige opdrachten kunnen uitvoeren. Een nadeel van toestandsgebaseerde ASM-schema's is dat we meer toestanden nodig hebben, wat zal leiden tot een groter geheugen en mogelijk ook logica.
\paragraph{}
De termen inputgebaseerd en toestandsgebaseerd komen van de controller. We hebben reeds besproken dat een controller een eindige toestandsautomaat is. Ook bij deze eindige toestandsautomaten hebben we deze indeling gemaakt. Een toestandsgebaseerd ASM-schema zal aanleiding geven tot een toestandsgebaseerde controller en vice versa. Bij wijze van voorbeeld zullen we het leidend voorbeeld ook met een toestandsgebaseerd ASM-schema visualiseren op figuur \ref{fig:aSMSchemaRunningExampleState}.
\begin{figure}[hbt]
\centering
\begin{tikzpicture}
\def\ds{6};
\def\di{1.75};
\def\dy{-2};
\def\offset{1};
\node[asmS] (S1S) at (0,0) {$\begin{array}{c}X\gets N\\Y\gets 0\\Z\gets 0\\I\gets 3\\co=0\end{array}$};
\node[asmD] (S1D) at (0,\dy) {$ci=0$};
\draw[->] (S1S) -- (S1D);
\draw[->] (S1D) -| (-\di,0) -- (S1S);
\setTrueFalseLabels{S1D};

\node[asmS] (S2S) at (\ds,0) {$\begin{array}{c}X\gets N\\co=0\end{array}$};
\node[asmD] (S2D1) at (\ds,\dy) {$z_2z_1z_0x_3<D$};
\draw[->] (S2S) -- (S2D1);
\node[asmS] (S4S) at (\ds-\di,2*\dy) {$\begin{array}{c}Z\gets z_2z_1z_0x_3\\I\gets I-1\\Y\gets Y\shlcmd{} 1\end{array}$};
\draw[->] (S2D1) -| (S4S);
\node[asmS] (S5S) at (\ds+\di,2*\dy) {$\begin{array}{c}Z\gets z_2z_1z_0x_3-D\\I\gets I-1\\Y\gets y_2y_1y_01\end{array}$};
\draw[->] (S2D1) -| (S5S);
\node[asmD] (S4D) at (\ds-\di,3*\dy) {$I>0$};
\draw[->] (S4S) -| (S4D);
\node[asmD] (S5D) at (\ds+\di,3*\dy) {$I>0$};
\draw[->] (S5S) -| (S5D);
\draw[->] (S1D) -| (\di,\offset) -| (S2S);
\draw[->] (S4D) -| (\ds-2*\di,0) -- (S2S);
\setTrueFalseLabels{S2D1};
\setTrueFalseLabels{S4D};
\setTrueFalseLabels{S5D};

\node[asmS] (S3S) at (2*\ds,0) {$\begin{array}{c}co=1\end{array}$};
\node[asmD] (S3D) at (2*\ds,\dy) {$ci=1$};
\node[asmN] (N1) at (2*\ds,2*\dy) {$\begin{array}{c}Q=Y\\R=Z\end{array}$};
\draw[->] (S4D) -| (\ds-0.375*\di,3.75*\dy) -| (\ds+2*\di,\offset) -| (S3S);
\draw (S5D) -| (\ds+0.375*\di,3.5*\dy) -| (\ds-2*\di,0 |- S4D);
\draw (S5D) -- (S5D -| \ds+2*\di,0);
\pdot{S5D -| \ds+2*\di,0}
\pdot{\ds-2*\di,0 |- S4D}
\draw[->] (S3S) -- (S3D);
\draw[->] (S3D) -| (2*\ds-\di,0) -- (S3S);
\draw[->] (S3D) -| (\di+2*\ds,1.5) -| (S1S);
\setTrueFalseLabels{S3D};
\begin{pgfonlayer}{background}
\node[asmB, fit=(S1S) (S1D)] (S1) {};
\node[asmB, fit=(S2S) (S2D1)] (S2) {};
\node[asmB, fit=(S3S) (S3D)] (S3) {};
\node[asmB, fit=(S4S) (S4D)] (S4) {};
\node[asmB, fit=(S5S) (S5D)] (S5) {};
\end{pgfonlayer}
\draw (S1.south west) node[anchor=south west]{$S_1$};
\draw (S2.south west) node[anchor=south west]{$S_2$};
\draw (S3.south west) node[anchor=south west]{$S_3$};
\draw (S5.south west) node[anchor=south west]{$S_4$};
\draw (S4.south west) node[anchor=south west]{$S_5$};
\end{tikzpicture}
\caption{Toestandsgebaseerd ASM-schema van het leidend voorbeeld.}
\label{fig:aSMSchemaRunningExampleState}
\end{figure}
\section{Geheugencomponenten}
\label{s:memoryFSMD}
Alvorens we processoren kunnen implementeren zullen we eerst nieuwe componenten moeten introduceren. We zullen we deze componenten introduceren in een logische volgorde waarbij componenten gebruik maken van eerder ge\"introduceerde componenten.
\subsection{Register File Cell (RFC)}
Een \termen{register file cell} is een uitbreiding op een geklokte D-flipflop. Het component bevat een klok-ingang $\mbox{Clk}$, data-ingangen $D_{\mbox{\small{in}}1},\ldots,D_{\mbox{\small{in}}m}$, data-uitgangen $D_{\mbox{\small{out}}1},\ldots,D_{\mbox{\small{out}}n}$, \termen{leespoorten $\mbox{RE}_1,\mbox{RE}_{n}$} (ook wel ``\termen{Read-Enabled}'' genoemd) en \termen{schrijfpoorten $\mbox{WE}_1,\ldots,\mbox{WE}_{\left\lceil\log_2m+1\right\rceil}$} (ook wel ``\termen{Write-Enabled}'' genoemd). Deze ingangen laten ons toe om te kiezen uit welke data-ingang we data willen inlezen en deze bij de klokflank willen opslaan. We zullen data geklokt wegschrijven, net zoals bij een D-flipflop. Indien alle schrijfpoorten $\mbox{WE}_i=0$ lezen we geen nieuwe waarde in, en blijft de oude waarde behouden. In de andere gevallen dienen de schrijfpoorten een binaire getal $a$ te bepalen vanuit welke data-ingang $d_{\mbox{\small{in}}a}$ we data inlezen. Indien er voor het aantal data-ingangen $m$ geen natuurlijk getal $l$ bestaat zodat $l=\log_2 m+1$, zal er bij alle overige write-enable configuraties, data ingelezen worden uit de laatste data-ingang. Daarnaast kunnen we op eender welke uitgang de inhoud van het geheugen plaatsen. Vandaar dat er per uitgang ook een read-enable ingang is voorzien. Indien we een laag signaal aanleggen op een read-enable ingang $\mbox{RE}_i$, zal de overeenkomstige uitgang $D_{\mbox{\small{out}}i}$ hoog impedant zijn. De toestand van de uitgangen is niet geklokt: indien we tijdens twee klokflanken in een read-enable ingang aanpassen zullen we mits enige vertraging het resultaat op de data-uitgang zien, we hoeven dus niet op een klokflank te wachten. Op figuur \ref{fig:registerFileCell} tonen we een implementatie van een Register File Cell met $m=n=2$.
\begin{figure}[hbt]
\centering
\begin{tikzpicture}
\node[dff] (D) at (0,0) {};
\node[mux4to1,rotate=90] (M) at (-1.75,0 |- D.D) {};
\draw (M.output) -- (D.D);
\node[tris] (T1) at (1.75,0 |- D.Q) {};
\node[tris] (T2) at (2.5,-0.25) {};
\draw (D.Q) -- (T1.x);
\draw (D.Q -| 1.25,0) |- (T2.x);
\draw (D.Q -| 1.25,0) |- (-2.25,1.5) |- (M.data0);
\draw (M.data3) -| (M.data2 -| -2.25,0);
\draw (M.data1) -- ++(-1,0) node[anchor=east,scale=0.85]{$D_{\mbox{\small{in}}1}$};
\draw (M.data2) -- ++(-1,0) node[anchor=east,scale=0.85]{$D_{\mbox{\small{in}}2}$};
\draw (D.Clk) -| (-1,-2) node[anchor=north,scale=0.85]{Clk};
\draw (T1.z) -- (T1.z -| 3.5,0) node[anchor=west,scale=0.85]{$D_{\mbox{\small{out}}1}$};
\draw (T2.z) -- (T2.z -| 3.5,0) node[anchor=west,scale=0.85]{$D_{\mbox{\small{out}}2}$};
\draw (T1.c) -- (T1.c |- 0,-1.75) node[anchor=north,scale=0.85]{$\mbox{RE}_1$};
\draw (T2.c) -- (T2.c |- 0,-1.75) node[anchor=north,scale=0.85]{$\mbox{RE}_2$};
\draw (M.selout1) -- (M.selout1 |- 0,2) node[anchor=south,scale=0.85]{$\mbox{WE}_2$};
\draw (M.selout0) -| (-1.125,2) node[anchor=south,scale=0.85]{$\mbox{WE}_1$};
\pdot{D.Q -| 1.25,0};
\pdot{M.data2 -| -2.25,0};
\setIndexLabelsMuxD[west]{M};
\node[rectangle,draw=black,dashed,inner sep=0.3cm, fit=(M) (D) (T1) (T2)] (S1) {};
\end{tikzpicture}
\caption{Implementatie van een Register File Cell (RFC) met $2$ lees- en $2$ schrijfpoorten}
\label{fig:registerFileCell}
\end{figure}
\subsection{Registerbank}
Een belangrijke toepassing van een Register File Cell is een \termen{registerbank}. Een registerbank bevat verschillende register file cellen, die geordend worden in matrixstructuur. We spreken dan ook over een \termen{$m\times n$ registerbank} met $k$ \termen{schrijfpoorten} en $l$ \termen{leespoorten}. Dit betekent dat het component $m$ sequenties van $n$ bits opslaat. We kunnen hierbij data op $k$ verschillende sequenties tegelijk schrijven, en de inhoud van $l$ verschillende sequenties uitlezen. Hiervoor dienen we volgende in- en uitgangen te voorzien:
\begin{itemize}
 \item \termen{invoer-ingangen $I_{ij}$}: een set van $k\times n$ ingangen om $k$ sequenties van $n$ bits te kunnen inlezen in de registerbank.
 \item \termen{write-enable-ingangen $\mbox{WE}_i$}: $k$ verschillende signalen waarmee we aangeven of de invoer op $I_{ij}$ ingangen moet worden ingelezen.
 \item \termen{write-address-ingangen $\mbox{WA}_{ia}$}: $k$ groepen van $\lceil\log_2m\rceil$ bits waarmee we aangeven op welk adres we de $n$ bits die op $I_{ij}$ staan zullen wegschrijven.
 \item \termen{uitvoer-uitgangen $O_{ij}$}: een reeks van $l\times n$ signalen die we gebruiken om data in de registerbank uit te lezen.
 \item \termen{read-enable-ingangen $\mbox{RE}_i$}: $l$ signalen die bepalen of we op de uitgangen $O_{ij}$ iets zullen uitlezen. Analoog aan de write-enable-ingangen.
 \item \termen{read-address-ingangen $\mbox{RA}_{ia}$}: $l$ groepen van $\left\lceil\log_2m\right\rceil$ bits bepalen welke sequentie -- binair voorgesteld op de adres-ingangen -- wordt uitgelezen. Dit is analoog aan de write-address-ingangen.
\end{itemize}
Een registerbank omvat twee scenarios: het inlezen van data en het uitlezen van data. Indien we een hoog signaal aanleggen op $\mbox{WE}_i$, zullen we de data die op de ingangen $I_{ij}$ staan wegschrijven naar het adres dat binair ge\"encodeerd is met de write-access ingangen $\mbox{WA}_{ia}$ voor $j=0\ldots n-1$ en $a=0\ldots\left\lceil\log_2m\right\rceil-1$. Dit doen we op de klokflank. Indien we een laag signaal aan de write-enable ingang plaatsen, wordt de inhoud die op de bijbehorende invoer-ingangen staat genegeerd. Bij het uitlezen van data is het signaal van de read-enable-ingang van belang. Indien we een hoog signaal aanleggen op $\mbox{RE}_i$ zullen de uitvoer-uitgangen $O_{ij}$ de waardes van de data opgeslagen in een adres, binair gevormd door de read-address-ingangen $\mbox{WA}_{ia}$, aannemen voor $j=0\ldots n-1$ en $a=0\ldots\left\lceil\log_2m\right\rceil-1$. Indien we een laag signaal aanleggen, zijn deze uitvoer-uitgangen hoog impedant. Uitlezen van data gebeurt ongeklokt: indien we bijvoorbeeld de read-adress signalen aanpassen, zullen de uitvoer-uitgangen zich aanpassen ongeacht de toestand van de kok op dat moment. Tot slot beschouwen we vaak een speciaal geval van een registerbank: de \termen{dual port registerbank} is een registerbank met \'e\'en lees- en \'e\'en schrijfpoort. Bijgevolg is in dat geval $k=l=1$.
\begin{figure}[hbt]
\centering
\begin{tikzpicture}

\end{tikzpicture}
\caption{Implementatie van een $4\times 3$ registerbank met $2$ schrijf- en $3$ leespoorten.}
\label{fig:registerbank}
\end{figure}
\paragraph{}
Op figuur \ref{fig:registerbank} beschouwen we een $4\times 3$ registerbank met $2$ schrijf- en $3$ leespoorten. We zullen hier het kloksignaal negeren vermits de klokingang van de registerbank het kloksignaal enkel verderpropageert naar de klokingangen van alle register file cellen. Verder zullen we ook een nieuwe notatie invoeren die we vanaf hier frequent zullen gebruiken: vaak zullen een groot aantal signalen parallell verschillende bits van het ene component naar het andere overbrengen. Vermits door de ori\"entatie van de het component meestal duidelijk is om welke signalen het gaat, zullen we niet elk signaal individueel tekenen. In dat geval stellen we de groep signalen voor met een brede lijn, en schrijven naast een dwarse streep het aantal signalen op die deze lijn voorstelt.
\subsection{Random Access Memory (RAM)}
\subsection{Stack (LIFO: Last-In-First-Out)}
\subsection{Queue (FIFO: First-In-First-Out)}
\section{Synthese van een Niet-Programmeerbare Processor}
\label{s:syntheseFSMD}
\section{Tijdsgedrag}
\label{s:timeFSMD}